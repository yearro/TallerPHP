<html>
<head>
<title>Manual de ADODB</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <style>
        pre {
          background-color: #eee;
          padding: 0.75em 1.5em;
          font-size: 12px;
          border: 1px solid #ddd;
          }
   </style>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
    _uacct = "UA-425709-1";
    urchinTracker();
</script>
</head>	
<body bgcolor="#FFFFFF">
        <div align=right>    <a href="readme-es.htm">Pagina principal ADODB en espa&ntilde;ol</a></div>
            <hr>


<h2>Libreria ADOdb para PHP</h2>
<p>V4.92 29 Ago 2006 (c) 2000-2006 John Lim (jlim#natsoft.com)</p>
<p><font size="1">Este programa tiene licencia dual BSD-Style y LGPL. Esto
  significa que lo puedes usar tanto en productos comerciales como en propietarios.</font></p>
    <p>Ligas utules de ADOdb:  <a href=http://adodb.sourceforge.net/#download>Descarga</a> &nbsp; <a href=http://adodb.sourceforge.net/#docs>Otros manuales (en ingles)</a> &nbsp; <a href=readme-es.htm>Otros manuales (en espa&ntilde;ol</a>

<p><a href="#intro"><b>Introduccion</b></a><b><br>
	<a href="#features">Caracteristicas Unicas</a><br>
	<a href="#users">Como se esta usando actualmente ADOdb</a><br>
	<a href="#bugs">Solicitud de mejoras y reporte de fallas</a><br>
	</b><b><a href="#install">Instalacion</a><br>
	<a href="#mininstall">Instalacion Minima</a><br>
	<a href="#coding">Codigo de Inicio y Ejemplos de conexion</a><br>
	<font size="2"> &nbsp; <a href=#dsnsupport>Soporte a DSN (Data Source Name)</a></font> 
	<font size="2"> &nbsp; <a href=#connect_ex>Ejemplos de conexion</a></font><br>
	<a href="#speed">ADOdb de alta velocidad - trucos de optimizacion</a></b><br>
	<b><a href="#hack">Modificando y extendiendo ADOdb con seguridad</a><br>
	<a href="#php5">Caracteristicas para PHP5</a></b><br>
	<font size="2"> &nbsp; <a href=#php5iterators>foreach iterators</a> <a href=#php5exceptions>exceptions</a></font><br>
	<b> <a href="#drivers">Base de datos soportadas</a></b><br>
	<b> <a href="#quickstart">Tutoriales</a></b><br>
	<a href="#ex1">Ejemplo 1: Select</a><br>
	<a href="#ex2">Ejemplo 2: Select avanzado</a><br>
	<a href="#ex3">Ejemplo 3: Insert</a><br>
	<a href="#ex4">Ejemplo 4: Depurando</a> &nbsp;<a href="#exrs2html">Ejemplo rs2html</a><br>
	<a href="#ex5">Ejemplo 5: MySQL y Menus</a><br>
	<a href="#ex6">Ejemplo 6: Conectarase a multiples bases de datos al mismo tiempo</a> <br>
	<a href="#ex7">Ejemplo 7: Generando enunciados SQL de Update e Insert</a> <br>
	<a href="#ex8">Ejemplo 8: Implementando cursores con Siguiente y Anterior</a><br>
	<a href="#ex9">Ejemplo 9: Exportando a formatos delimitados por Tabulador o comas</a> <br>
	<a href="#ex10">Ejemplo 10: Filtros a la medida</a><br>
	<a href="#ex11">Ejemplo 11: Transacciones inteligentes</a><br>
	<br>
	<b> <a href="#errorhandling">Usando manejadores de errores a la medida o de PEAR</a><br>
	<a href="#DSN">Nombres de DSN</a><br>
	<a href="#caching">Memoria intermedia (Caching)</a><br>
	<a href="#pivot">Tablas Pivote</a></b> 
<p><a href="#ref"><b>REFERENCIA</b></a>
<p> <font size="2">Variables: <a href="#adodb_countrecs">$ADODB_COUNTRECS</a> <a href=#adodb_ansi_padding_off>$ADODB_ANSI_PADDING_OFF</a>
    <a href="#adodb_cache_dir">$ADODB_CACHE_DIR</a> <a href="#force_type">$ADODB_FORCE_TYPE</a>
    <a href=#adodb_fetch_mode>$ADODB_FETCH_MODE</a> 
  <a href=#adodb_lang>$ADODB_LANG</a><br>
  Constantes: <a href=#adodb_assoc_case>ADODB_ASSOC_CASE</a> 
  <br>
  <a href="#ADOConnection"><b> ADOConnection</b></a><br>
  Conecciones: <a href="#connect">Connect</a> <a href="#pconnect">PConnect</a> 
  <a href="#nconnect">NConnect</a> <a href="#isconnected">IsConnected</a><br>
  Ejecutando SQL: <a href="#execute">Execute</a> <a href="#cacheexecute"><i>CacheExecute</i></a> 
  <a href="#SelectLimit">SelectLimit</a> <a href="#cacheSelectLimit"><i>CacheSelectLimit</i></a> 
  <a href="#param">Param</a> <a href="#prepare">Prepare</a> <a href=#preparesp>PrepareSP</a> 
  <a href="#inparameter">InParameter</a> <a href="#outparameter">OutParameter</a>
  <a href="#autoexecute">AutoExecute</a>
  <br>
  &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#getone">GetOne</a> 
  <a href="#cachegetone"><i>CacheGetOne</i></a> <a href="#getrow">GetRow</a> <a href="#cachegetrow"><i>CacheGetRow</i></a> 
  <a href="#getall">GetAll</a> <a href="#cachegetall"><i>CacheGetAll</i></a> <a href="#getcol">GetCol</a> 
  <a href="#cachegetcol"><i>CacheGetCol</i></a> <a href="#getassoc1">GetAssoc</a> <a href="#cachegetassoc"><i>CacheGetAssoc</i></a> <a href="#replace">Replace</a> 
  <br>
  &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#executecursor">ExecuteCursor</a> 
  (oci8 unicamente)<br>
  Generando enunciados SQL: <a href="#getupdatesql">GetUpdateSQL</a> <a href="#getinsertsql">GetInsertSQL</a> 
  <a href="#concat">Concat</a> <a href="#ifnull">IfNull</a> <a href="#length">length</a> <a href="#random">random</a> <a href="#substr">substr</a> 
  <a href="#qstr">qstr</a> <a href="#param">Param</a> 
  <a href="#prepare"></a><a href="#OffsetDate">OffsetDate</a> <a href="#SQLDate">SQLDate</a> 
  <a href="#dbdate">DBDate</a> <a href="#dbtimestamp"></a> <a href="#dbtimestamp">DBTimeStamp</a>
  <a href="#binddate">BindDate</a> <a href="#bndtimestamp">BindTimeStamp</a>
  <br>
  Blobs: <a href="#updateblob">UpdateBlob</a> <a href="#updateclob">UpdateClob</a> 
  <a href="#updateblobfile">UpdateBlobFile</a> <a href="#blobencode">BlobEncode</a> 
  <a href="#blobdecode">BlobDecode</a><br>
  Paginacion/Desplazamiento: <a href="#pageexecute">PageExecute</a> <a href="#cachepageexecute">CachePageExecute</a><br>
  Limpieza: <a href="#cacheflush">CacheFlush</a> <a href="#Close">Close</a><br>
  Transacciones: <a href="#starttrans">StartTrans</a> <a href="#completetrans">CompleteTrans</a> 
  <a href="#failtrans">FailTrans</a> <a href="#hasfailedtrans">HasFailedTrans</a> 
  <a href="#begintrans">BeginTrans</a> <a href="#committrans">CommitTrans</a> 
  <a href="#rollbacktrans">RollbackTrans</a><a href="#settransactionmode">SetTransactionMode</a><br>
  Recuperando Datos: <a href="#setfetchmode">SetFetchMode</a><br>
  Cadenas: <a href="#concat">concat</a> <a href="#length">length</a>  <a href="#qstr">qstr</a> <a href="#quote">quote</a> <a href="#substr">substr</a><br>
  Fechas: <a href="#dbdate">DBDate</a> <a href="#dbtimestamp">DBTimeStamp</a> <a href="#unixdate">UnixDate</a> 
  <a href="#unixtimestamp">UnixTimeStamp</a> <a href="#OffsetDate">OffsetDate</a> 
  <a href="#SQLDate">SQLDate</a> <br>
  Renglones: <a href="#affected_rows">Affected_Rows</a> <a href="#inserted_id">Insert_ID</a>  <a href=#rowlock>RowLock</a>
  <a href="#genid">GenID</a> <a href=#createseq>CreateSequence</a> <a href=#dropseq>DropSequence</a> 
  <br>
  Manejo de Errores: <a href="#errormsg">ErrorMsg</a> <a href="#errorno">ErrorNo</a> 
  <a href="#metaerror">MetaError</a> <a href="#metaerrormsg">MetaErrorMsg</a>
  <a href="#ignoreerrors">IgnoreErrors</a>
  <br>
  Diccionario de datos (metadata): <a href="#metadatabases">MetaDatabases</a> <a href="#metatables">MetaTables</a> 
  <a href="#metacolumns">MetaColumns</a> <a href="#metacolumnames">MetaColumnNames</a> 
  <a href="#metaprimarykeys">MetaPrimaryKeys</a> <a href="#metaforeignkeys">MetaForeignKeys</a> 
  <a href="#serverinfo">ServerInfo</a> <br>
  Estadisticas y modifacion de SQL: <a href="#logsql">LogSQL</a> <a href="#fnexecute">fnExecute 
  and fnCacheExecute</a><br>
  Descontinuado: <a href="#bind">Bind</a> <a href="#blankrecordset">BlankRecordSet</a>
  <a href="#parameter">Parameter</a>
  </font>
  <a href="#adorecordSet"><b><br>ADORecordSet</b></a><br>
  <font size="2">
  Regresa un campo: <a href="#fields">Fields</a><br>
 Regresa un renglon:<a href="#fetchrow">FetchRow</a> <a href="#fetchinto">FetchInto</a> 
  <a href="#fetchobject">FetchObject</a> <a href="#fetchnextobject">FetchNextObject</a> 
  <a href="#fetchobj">FetchObj</a> <a href="#fetchnextobj">FetchNextObj</a>
 <a href="#getrowassoc">GetRowAssoc</a> <br>
  Regresa todos los renglones:<a href="#getarray">GetArray</a> <a href="#getrows">GetRows</a> 
  <a href="#getassoc">GetAssoc</a><br>
  Desplazamiento:<a href="#move">Move</a> <a href="#movenext">MoveNext</a> <a href="#movefirst">MoveFirst</a> 
  <a href="#movelast">MoveLast</a> <a href="#abspos">AbsolutePosition</a> <a href="#currentrow">CurrentRow</a> 
  <a href="#atfirstpage">AtFirstPage</a> <a href="#atlastpage">AtLastPage</a> 
  <a href="#absolutepage">AbsolutePage</a> <br>
  Generacion de Menu:<a href="#getmenu">GetMenu</a> <a href="#getmenu2">GetMenu2</a><br>
  Fechas:<a href="#userdate">UserDate</a> <a href="#usertimestamp">UserTimeStamp</a> 
  <a href="#unixdate">UnixDate</a> <a href="#unixtimestamp">UnixTimeStamp<br>
  </a>Informacion del Recordset:<a href="#recordcount">RecordCount</a> <a href="#po_recordcount">PO_RecordSet</a> 
  <a href="#nextrecordset">NextRecordSet</a><br>
  Informacion de un campo:<a href="#fieldcount">FieldCount</a> <a href="#fetchfield">FetchField</a> 
  <a href="#metatype">MetaType</a><br>
  Limpieza: <a href="#rsclose">Close</a>
<p><a href="#rs2html"><b>rs2html</b></a>&nbsp; <a href="#exrs2html">ejemplo</a>
</font><br>
  <a href="#adodiff">Diferencias entre ADOdb y ADO</a><br>
  <a href="#driverguide"><b>Guia para manejadores de base de datos<br>
  </b></a><b><a href="#changes">Bitacora de cambios</a></b><br>
</p>
<h2>Introduccion<a name="intro"></a></h2>
<p>Las funciones de acceso a base de datos en PHP no estan estandarizadas. Esto requiere 
  una libreria que esconda las diferencias entre cada API de base de datos
  (encapsular las diferencias) para que podamos cambiar facilmente de base de datos. Se 
  requiere la version de PHP 4.0.5 o posterior (debido a que usamos la funcion str_replace con arreglos).</p>
<p>Actualmente manejamos MySQL, Oracle, Microsoft SQL Server, Sybase, Sybase SQL Anywhere, Informix, 
  PostgreSQL, FrontBase,  SQLite, Interbase (versiones de Firebird y Borland), Foxpro, Access, ADO, DB2, SAP DB and ODBC. 
  Tenemos noticias que se puede conectar a Progress y CacheLite via ODBC. 
  Esperamos que mas personas contribuyan con drivers para manejar mas base de datos.</p>
<p>PHP4 maneja variables de sesion. Puedes almacenar la informacion de tu sesion usando
    ADOdb para tener una verdadera portabilidad y escalabilidad. 
   Para mas informacion ve el archivo adodb-session.php.</p>
<p>Tambie lee <a href="tips_portable_sql-es.htm"> tips_portable_sql-es.htm</a> 
  (tambien dispobible en ingles en el archivo <a href="tips_portable_sql.htm">tips_portable_sql.htm</a>) para consejos para escribir enunciados SQL portables.</p>
<h2>Caracteristicas especiales de ADOdb<a name="features"></a></h2>
<ul>
  <li><b>Facil para programadores Windows</b> debido a que muchas de las convenciones
    son similares al ADO de Microsoft.</li>
  <li>A diferencia de otras clases PHP de base de datos que se enfocas unicamente en el
      enunciado SELECT. 
	<b>ADOdb soporta codigo para manajar INSERT y UPDATE que son rapidamente adaptables
    a multiples bases de datos.</b> Tambien hay metodos para manejo de fechas,
    concatenacion de cadenas y encomillado de cadenas para diferentes bases de datos.</li>
  <li>Tiene un <b> systema de metatipos (metatype)</b> para poder determinar cuales
     tipos como CHAR, TEXT and STRING son equivalentes en diferentes bases de datos.</li>
  <li>Es <b>facil de portar</b> debido a que todo el codigo que depende de la base de datos
    esta en funciones. Tu no tienes que portar la logica principal de las clases.</li>
  <li><b>Creacion de tablas e indices portable</b> con las clases de diccionario de datos <a href=docs-datadict-es.htm>datadict</a>.
  <li><b>Monitor de rendimiento de base de datos y ajuste de enunciados SQL</b> con la clase de
  <a href=docs-perf-es.htm>performance monitoring</a>.
  <li><b>Sesiones en  base de datos</b> con la clase <a href=docs-session-es.htm>session management</a>. Maneja notificacion por sesion vencida.
  <li><b>Mapeo a Objectos Relacionales</b> uando la clase <a href=docs-active-record-es.htm>ADOdb_Active_Record</a>.
</ul>
<h2>Como se esta usando ADOdb<a name="users"></a></h2>
Aqui hay algunos ejemplos de personas que usan ADOdb (para una lista mas larga,
visita <a href="http://adodb.sourceforge.net/">http://adodb.sourceforge.net/</a>): 
<ul>
<li><a href="http://phplens.com/">PhpLens</a> es un componente comercial de cudricula de datos
   que permite tanto a programadores expertos como a inexpertos desarrollar y mantener bases de
   datos en la Web facilmente. Desarrollado por el autor de ADOdb.<p>

<li><a href="http://www.interakt.ro/phakt/">PHAkt: PHP Extension for DreamWeaver Ultradev</a> 
   permite hacer programas PHP en el popular editor de paginas Web. 
   El manejo de la base de datos es con ADOdb.<p>

<li><a href="http://www.andrew.cmu.edu/~rdanyliw/snort/snortacid.html">Analysis Console for Intrusion Databases</a> 
    (ACID): Motor de analisis para buscar y procesar una base de datos de 
    incidentes de seguridad generada por otros programas como IDSes y firewalls 
    (e.g. Snort, ipchains). Por Roman Danyliw.<p>

<li><a href="http://www.postnuke.com/">PostNuke</a> es una sistema de control de contenidos muy
popular. Maneja un soporte completo de CSS, cumple con HTML 4.01, un sistema avanzado de bloques, y es 
completamente multilenguaje.<p>

<li><a href=http://www.auto-net.no/easypublish.php?page=index&lang_id=2>EasyPublish CMS</a> 
es otro sistema de control de contenidos. Para el manejo de informacion y modulos integrados para tu internet, intranet y extranet. Noruego.<p>

<li><a href="http://nola.noguska.com/">NOLA</a> es una apliacion completa de contabilidad, inventarios y control de trabajo. Su licencia es GPL, desarrollado por Noguska.</ul><p>

<h2>Solicitud de mejoras y reporte de fallas<a name="bugs"></a></h2>
<p>Las solicitudes de mejoras o reporte de fallas pueden ser enviadas por correo electronico a
  <a href="mailto:jlim#natsoft.com.my">jlim#natsoft.com.my</a> o publicadas en el foro de ayuda
  de ADOdb en <a href="http://phplens.com/lens/lensforum/topics.php?id=4">http://phplens.com/lens/lensforum/topics.php?id=4</a>.</p>
<h2>Guia de Instalacion<a name="install"></a></h2>
<p>Asegurate de estar usando PHP 4.0.5 o posterior. 
  Descomprime todos los archivos en un directorio accesible por tu servidor Web.</p>
<p>Para probar, intenta modificar algunos de los ejemplos del tutorial. Asegurate de corregir
  los parametros de coneccion a tus necesidades.
  Puedes depurar el codigo usando <i>$db->debug = true</i> como se muestra a continuacion:</p>
<pre>&lt;?php
	include('adodb/adodb.inc.php');
	$db = <a href="#adonewconnection">ADONewConnection</a>($dbdriver); # eg 'mysql' o 'postgres'
	$db->debug = true;
	$db-><a href="#connect">Connect</a>($servidor, $usuario, $contraseña, $database);
	$rs = $db-><a href="#execute">Execute</a>('select * from alguna_tabla_pequeña');
	print &quot;&lt;pre&gt;&quot;;
	print_r($rs-><a href="#getrows">GetRows</a>());
	print &quot;&lt;/pre&gt;&quot;;
?&gt;</pre>

 <h3>Instalacion Minima<a name=mininstall></a></h3>
<p>Para los desarrolladores que quieran distribuir una version minima de ADOdb, se requieren los siguientes archivos:
<ul>
<li>adodb.inc.php
<li>adodb-lib.inc.php
<li>adodb-time.inc.php
<li>drivers/adodb-$database.inc.php
<li>license.txt (por razones legales)
<li>adodb-php4.inc.php
<li>adodb-iterator.inc.php (funcionaldiad para PHP5)
</ul>
Opcionalmente:
<ul>
<li>adodb-error.inc.php y lang/adodb-$lang.inc.php (si usas MetaError())
<li>adodb-csvlib.inc.php (si usas recordsets en memoria - CacheExecute(), etc)
<li>adodb-exceptions.inc.php y adodb-errorhandler.inc.php (si usas el manejo de errores de ADOdb o excepciones de PHP5).
<li>adodb-active-record.inc.php si usas <a href="docs-active-record-es.htm">Active Records</a>.
</ul>

<h3>Ejemplos de Codigo de Inicio<a name="coding"></a></h3>
<p>Al ejecutar ADOdb, al menos se cargan dos archivos. Primero adodb/adodb.inc.php, 
 que contienen todas las funciones usadas por todas las clases de bases de datos.
 El codigo especifico a una base de datos en particular esta en el archivo
 adodb/driver/adodb-????.inc.php.</p>
 <a name="adonewconnection"></a>
<p>Por ejemplo, para conectarse a una base de datos mysql:</p>
<pre>
include('adodb/adodb.inc.php');
$conn = &amp;ADONewConnection('mysql');
</pre>
<p>Cada vez que necesitas conectarte a una base de datos, debes de crear un objeto de conexion
   usando la funcion <b>ADONewConnection</b>($driver). 
  <b>NewADOConnection</b>($driver) es un nombre alterno para la misma funcion.</p>

  <p>En este momento, no estas conectado a la base de datos (ya no es cierto si como parametro usas un 
  <a href="#dsnsupport">dsn</a>). Primero tienes que decidir
   si vas a usar una coneccion <i>persistente</i> o <i>no persistente</i>. La ventaja de las
   conexiones <i>persistentes</i> es que son mas rapidas, debido a que la conexion no es cerrada
   nunca (aun si usas Close()). Las conexiones <i>No persistentes</i> consumen menos recursos
   reduciendo el riesgo de sobrecargar la base de datos o el servidor Web.
<p>Para conexiones persistentes, usa $conn-&gt;<a href="http://phplens.com/adodb/reference.functions.pconnect.html">PConnect()</a>,
 o $conn-&gt;<a href="http://phplens.com/adodb/reference.functions.connect.html">Connect()</a> para conexiones no persistentes.
   Algunas bases de datos tambien manejan <a href="http://phplens.com/adodb/reference.functions.nconnect.html">NConnect()</a>,
   la cual forza la creacion de una nueva conexion.
<a name=connection_gotcha></a>
<p><i>Problemas con Conexiones</i>:  Si creas dos conexiones, pero ambas usan el mismo usuario y
    contraseña, PHP compartira las conexiones. Esto puede causar problemas si se supone que las 
    conexiones son a diferentes bases de datos. La solucion es usar siempre diferentes usuarios
    para diferentes bases de datos o usar NConnect().</p>

<a name="dsnsupport"></a>
<h3>Soporte a Data Source Name (DSN)</h3>
 <p> Desde la version 4.51 de ADOdb, te puedes conectar a la base de datos pasando como argumento a NewADOConnection() 
     (o ADONewConnection, que es la misma funcion) un dsn. El formato del dsn es:
</p><pre>   $driver://$username:$password@hostname/$database?options[=value]<br></pre><p>
NewADOConnection() llama a Connect() o PConnect() internamente por ti. Si la conexion falla, te regresa <i>false</i>.
</p><pre>   <font color="#008000"># Conexion no persistente</font>
    $dsn = 'mysql://root:pwd@localhost/mydb'; 
    $db = NewADOConnection($dsn);
    if (!$db) die("Conexion incorrecta");   
    
    <font color="#008000"># no se requiere llamar connect/pconnect!</font>
    $arr = $db-&gt;GetArray("select * from table");
    
    <font color="#008000"># conexion persistente</font>
    $dsn2 = 'mysql://root:pwd@localhost/mydb?persist'; 
</pre>
<p>
Si tienes caracteres especiales como /:?_ en tu dsn, entonces tienes que invocar a rawurlencode primero:
</p><pre>   $pwd = rawurlencode($pwd);<br>  $dsn = "mysql://root:$pwd@localhost/mydb";
    $dsn2=rawurlencode("sybase_ase")."://user:pass@host/path?query";<br></pre>
<p>
Las opciones permitidas son:
</p><p>
<table align="center" border="1"><tbody><tr><td>Para todas los drivers</td><td>
    'persist', 'persistent', 'debug', 'fetchmode', 'new'
    </td></tr><tr><td>Interbase/Firebird
    </td><td>
                     'dialect','charset','buffers','role'
    </td></tr><tr><td>M'soft ADO</td><td>
                     'charpage'
                    
        </td></tr><tr><td>MySQL</td><td>
                    'clientflags'
</td></tr><tr><td>MySQLi</td><td>
    'port', 'socket', 'clientflags'
</td></tr><tr><td>Oci8</td><td>
 'nls_date_format','charset'
</td></tr></tbody></table>
</p><p> 
Para todos los drivers, cuando se activa la opcion <i>persist</i> o <i>persistent</i>,  se forza una conexionpersistente; 
asi mismo, cuando se activa <i>new</i>, entonces la conexion se creara usando NConnect si el driver lo maneja.
La opcion <i>debug</i> habilita la depuracion. La opcion <i>fetchmode</i> invoca <a href="#setfetchmode">SetFetchMode()</a>.
Si no se le indica el valor a alguna oopcion se asume el valor de 1.
</p><p>
La version DSN de ADOdb DSN es compatible con el formato de la version 1.0 de PEAR DB.


<h3>Ejemplos de Conexion a Bases de Datos</h3>
<h4>MySQL y la mayoria de bases de datos</h4>
<p>Las conexiones a MySQL son muy sencillas, y los parametros son identicos a mysql_connect:</p>
<pre><a name="connect_ex">    $conn = &amp;ADONewConnection('mysql'); <br>    $conn-&gt;PConnect('localhost','usuario','contraseña','database');
<br>    <font color="#008000"># o dsn </font>
    $dsn = 'mysql://user:pwd@localhost/mydb'; 
    $conn = ADONewConnection($dsn);  # no necesita Connect()
    
    <font color="#008000"># o dsn persistente </font>
    $dsn = 'mysql://user:pwd@localhost/mydb?persist'; 
    $conn = ADONewConnection($dsn);  # no necesita PConnect()
    
    <font color="#008000"># un ejemplo mas complejo:</font>
    $pwd = urlencode($pwd);
    $flags =  MYSQL_CLIENT_COMPRESS;
    $dsn = "mysql://user:$pwd@localhost/mydb?persist&amp;clientflags=$flags";
    $conn = ADONewConnection($dsn);  # no need for PConnect()
 </pre>
<p> La mayoria de las demas bases de datos usan la misma convencion: Connect($servidor, $usuario, $contraseña, $database). Las excepciones se enlistas a continuacion.</p>

<a name=pdo>
<h4>PDO</h4>
<p>PDO, que solo funciona en PHP5, acepta una cadena de driver especifica:
<pre>
    $conn =& NewADConnection('pdo');
    $conn->Connect('mysql:host=localhost',$user,$pwd,$mydb);
    $conn->Connect('mysql:host=localhost;dbname=mydb',$user,$pwd);
    $conn->Connect("mysql:host=localhost;dbname=mydb;username=$user;password=$pwd");
</pre>
<p>El mecanismo via DSN tambien funciona:
<pre>
    $conn =& NewADConnection("pdo_mysql://user:pwd@localhost/mydb?persist"); # persist es opcional
</pre>


<h4>PostgreSQL</h4>
<p>PostgreSQL 7 y 8 acepta conexiones usando: </p>
<p>a. La cadena estandard de conexcion:</p>
<pre>
	$conn = &amp;ADONewConnection('postgres'); 
	$conn-&gt;PConnect('host=localhost port=5432 dbname=maria');</pre>
<p> b. Los 4 parametros clasicos:</p>
 <pre>
	$conn-&gt;PConnect('localhost','usuario','contraseña','database');
 </pre>
<p>c. dsn:
</p><pre>   $dsn = 'postgres://user:pwd@localhost/mydb?persist';  # persist es opcional
    $conn = ADONewConnection($dsn);  # no se requiere Connect/PConnect<br></pre>


<a name=ldap>
 <h4>LDAP</h4>
  <p>Este es un ejemplo de busqueda en un servidor LDAP. Gracias a Josh Eldridge por el driver y este ejemplo:
<pre>
 &lt;?php
require('adodb/adodb.inc.php');

/* Make sure to set this BEFORE calling Connect() */
$LDAP_CONNECT_OPTIONS = Array(
    Array ("OPTION_NAME"=>LDAP_OPT_DEREF, "OPTION_VALUE"=>2),
    Array ("OPTION_NAME"=>LDAP_OPT_SIZELIMIT,"OPTION_VALUE"=>100),
    Array ("OPTION_NAME"=>LDAP_OPT_TIMELIMIT,"OPTION_VALUE"=>30),
    Array ("OPTION_NAME"=>LDAP_OPT_PROTOCOL_VERSION,"OPTION_VALUE"=>3),
    Array ("OPTION_NAME"=>LDAP_OPT_ERROR_NUMBER,"OPTION_VALUE"=>13),
    Array ("OPTION_NAME"=>LDAP_OPT_REFERRALS,"OPTION_VALUE"=>FALSE),
    Array ("OPTION_NAME"=>LDAP_OPT_RESTART,"OPTION_VALUE"=>FALSE)
);

$host = 'ldap.baylor.edu';
$ldapbase = 'ou=People,o=Baylor University,c=US';

$ldap = NewADOConnection( 'ldap' );
$ldap->Connect( $host, $user_name='', $password='', $ldapbase );

echo "&lt;pre>";

print_r( $ldap->ServerInfo() );
$ldap->SetFetchMode(ADODB_FETCH_ASSOC);
$userName = 'eldridge';
$filter="(|(CN=$userName*)(sn=$userName*)(givenname=$userName*)(uid=$userName*))";

$rs = $ldap->Execute( $filter );
if ($rs)
	while ($arr = $rs->FetchRow()) {
	     print_r($arr);	
	}

$rs = $ldap->Execute( $filter );
if ($rs) 
	while (!$rs->EOF) {
 		print_r($rs->fields);	
		$rs->MoveNext();
	} 
	
print_r( $ldap->GetArray( $filter ) );
print_r( $ldap->GetRow( $filter ) );

$ldap->Close();
echo "&lt;/pre>";
?></pre>
<p>Using DSN:
<pre>
$dsn = "ldap://ldap.baylor.edu/ou=People,o=Baylor University,c=US";
$db = NewADOConnection($dsn);
</pre>


<h4>Interbase/Firebird</h4>
Hay que definir la base de datos en el parametro $host:
<pre>
	$conn = &ADONewConnection('ibase'); 
	$conn->PConnect('localhost:c:\ibase\employee.gdb','sysdba','masterkey');
</pre>
<p>O con dsn:
</p><pre>   $dsn = 'firebird://user:pwd@localhost/mydb?persist&amp;dialect=3';  # persist es opcional
   $conn = ADONewConnection($dsn);  # no se requiere Connect/PConnect<br></pre>
<h
<h4>SQLite</h4>
Sqlite creara la base de datos si no existe.
<pre>
	$conn = &ADONewConnection('sqlite'); 
	$conn->PConnect('c:\path\to\sqlite.db'); # sqlite la creara si no existe
</pre>
<p>O con dsn:
</p><pre>   $path = urlencode('c:\path\to\sqlite.db');
    $dsn = "sqlite://$path/?persist";  # persist es opcional
    $conn = ADONewConnection($dsn);  # no se requiere Connect/PConnect<br></pre>

<h4>Oracle (oci8)</h4>
<p>Con oci8 te puedes conectar de varias maneras.</p>
<p>a. PHP y Oracle estan en la misma maquina, usar SID.</p>
<pre>	$conn-&gt;Connect(false, 'scott', 'tiger');</pre>
<p>b. Nombre TNS definido en tnsnames.ora (o ONAMES o HOSTNAMES), ej. 'miTNS'</p>
<pre>	$conn-&gt;PConnect(false, 'scott', 'tiger', 'miTNS');
</pre>
<p>o</p>
<pre> 	$conn-&gt;PConnect('miTNS', 'scott', 'tiger');</pre>
<p>c. Direccion del servidor y SID</p>
<pre>       $conn->connectSID = true;<br>       $conn-&gt;Connect('192.168.0.1', 'scott', 'tiger', 'SID');</pre>
<p>d. Direccion del servidor y nombre del servicio</p>
<pre>	$conn-&gt;Connect('192.168.0.1', 'scott', 'tiger', 'servicename');</pre>
<p>e. Cadena de conexion de Oracle:
</p><pre>
    $cstr = "(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=$host)(PORT=$port))(CONNECT_DATA=(SID=$sid)))";
    $conn-&gt;Connect($cstr, 'scott', 'tiger');<br></pre>
<p>f. ADOdb dsn:
</p><pre>
    $dsn = 'oci8://user:pwd@tnsname/?persist';  # persist is optional
    $conn = ADONewConnection($dsn);  # no need for Connect/PConnect

    $dsn = 'oci8://user:pwd@host/sid';
    $conn = ADONewConnection($dsn);

    $dsn = 'oci8://user:pwd@/';   # oracle on local machine
    $conn = ADONewConnection($dsn);
</pre>
<p>Tamnbien puedes usar el charSet para Oracle 9.2 y posterior, soportado desde PHP 4.3.2, ADOdb 4.54:
</p><pre>
    $conn-&gt;charSet = 'we8iso8859p1';
    $conn-&gt;Connect(...);

    # o
    $dsn = 'oci8://user:pwd@tnsname/?charset=WE8MSWIN1252';
    $db = ADONewConnection($dsn);
</pre>

<a name=dsnless></a>
<h4>DSN-less ODBC (ejemplos con access and mssql)</h4>
<p>Las conexiones DSN via ODBC pueden ser creadas en el panel de control de ODBC, 
   o puedes usar una conexion DSN-less. 
   Para usar una conexion DSN-less se necesita PHP version 4.3 o posterior.
</p>
<p>Para Microsoft Access:</a></p>
<pre>
	$db =& ADONewConnection('access');
	$dsn = <strong>"Driver=&#123;Microsoft Access Driver (*.mdb)&#125;;Dbq=d:\\northwind.mdb;Uid=Admin;Pwd=;";</strong>
	$db->Connect($dsn);
</pre>
Para Microsoft SQL Server: 
<pre>
	$db =& ADONewConnection('odbc_mssql');
	$dsn = <strong>"Driver=&#123;SQL Server&#125;;Server=localhost;Database=northwind;"</strong>;
	$db->Connect($dsn,'userid','password');
</pre>
o si lo prefieres, se puede usar la extension mssql (que esta limitada a la funcionalildad de la version 6.5):
<pre>   $db =&amp; ADONewConnection('mssql');<br>   $db-&gt;Execute('localhost', 'userid', 'password', 'northwind');<br></pre>
Para DB2:
<pre>
    $dbms = 'db2'; # or 'odbc_db2' if db2 extension not available
    $db =&amp; ADONewConnection($dbms);
    $dsn = "driver={IBM db2 odbc DRIVER};Database=sample;hostname=localhost;port=50000;protocol=TCPIP;".
                "uid=root; pwd=secret";
    $db-&gt;Connect($dsn);
</pre>

<b>Conexiones DSN-less con ADO</b><br>
Si estas usando una version de PHP anterior a 4.3.0, Las conexiones DSN-less solo trabajaran
con el ADO de Microsoft, el cual esta basada en las APIs COM de Microsoft. 
Un ejemplo de uso de la libreria ADOdb y el ADO de Microsoft:
<pre>
&lt;?php
	include('adodb.inc.php'); 
	$db = &ADONewConnection("ado_mssql");
	print "&lt;h1>Connecting DSN-less $db->databaseType...&lt;/h1>";
		
	<b>$myDSN="PROVIDER=MSDASQL;DRIVER=&#123;SQL Server&#125;;"
		. "SERVER=flipper;DATABASE=ai;UID=sa;PWD=;"  ;</b>
	$db->Connect($myDSN);
	
	$rs = $db->Execute("select * from table");
	$arr = $rs->GetArray();
	print_r($arr);
?>
</pre>
<a name=speed></a>
<h2>ADOdb de alta velocidad - trucos de optimizacion</h2>
<p>La libreria ADOdb es una clase grande, aun asi <a href=http://phplens.com/lens/adodb/>regularmente derrota</a> a las 'otras' clases PHP en rendimiento.
  Esto es por su diseño en forma de capas, como una cebolla, con las funciones mas rapidas
  en la capa mas profunda. 
  Usa principalmente estas funciones para el mejor rendimiento:</p>
<table width="40%" border="1" align="center">
  <tr>
    <td><div align="center"><b>Capa mas profunda</b></div></td>
  </tr>
  <tr> 
    <td><p align="center">Connect, PConnect, NConnect<br>
        Execute, CacheExecute<br>
        SelectLimit, CacheSelectLimit<br>
        MoveNext, Close <br>
		qstr, Affected_Rows, Insert_ID</p></td>
  </tr>
</table>
<p>La manera mas rapida de acceder a los campos es usando el arreglo array $recordset->fields.
  Tambien hay que asignar la variable global <a href="#adodb_fetch_mode">$ADODB_FETCH_MODE</a> 
  = ADODB_FETCH_NUM, y (para oci8, ibase/firebird y odbc) <a href="#adodb_countrecs">$ADODB_COUNTRECS</a> = false 
  antes de conectarse a la base de datos. Esto al momento (Dec 2003).</p>
<p>Considera usar parametros posisicionales (bind) si tu base de datos los soporta, ya que
  mejora la reutilizacion de los planes de ejecucion.
  Usa el sistema de <a href="docs-perf.htm">'performance tuning</a> de ADodb para identificar
  rapidamente los cuellos de botella.
<p>Finalmente asegurate de que tienes un acelerador de PHP instalado como APC, Turck 
  MMCache, Zend Accelerator o ionCube.</p>
<p>Algunos ejemplos:</p>
 <table align="center" border="1"><tbody><tr><td><b>Recuperacion de datos mas rapida usando PHP</b></td><td><b>Recuperacion de datos mas rapida usando la extension ADOdb</b></td></tr>
<tr><td>
<pre>$rs =&amp; $rs-&gt;Execute($sql);<br>while (!$rs-&gt;EOF) {<br>    var_dump($rs-&gt;fields);<br>   $rs-&gt;MoveNext();<br>}</pre></td><td>
<pre>$rs =&amp; $rs-&gt;Execute($sql);<br>$array = adodb_getall($rs);<br>var_dump($array);<br><br><br></pre></td></tr></tbody></table>
 <p><b>Sugerencias Avanzadas</b>
 </p><p>Si tienes instalada la <a href="http://adodb.sourceforge.net/#extension">extension C ADOdb</a>,
 puedes modificar tus llamados a $rs-&gt;MoveNext() por adodb_movenext($rs). 
 Esto duplica la velocidad de esta operacion. Para obtener todo un conjunto de rsultados en una operacion,
usa GetArray(), el cual usa internamente la funcion de alta velocidad de la extension adodb_getall($rs).
 </p><p>Execute() es la manera usal para ejecutar enunciados SQL. Puedes usar la funcion de bajo nivel _Execute() y _query()
para reducir el costo. Ambas funciones comparten los mismos parametros que Execute().
</p><p>Si no tienes ningun parametro posicional o si tu base de datos soporta los parametros posicionales (sin
emulacion), entonces puedes llamar _Execute() directamente. AL invocar esta funcion eliminas la emulacion de parametros.
La depuracion tambien es manejada por _Execute().
</p><p>Si no requuieres depuracion ni emulacion de parametros, no requieres obtener un recordset, entonces puedes
llamar _query. Es muy buena para inserts, updates y deletes. Al invocar esta funcion omites la emulacion de parametros,
la depuracion y el majejo de recordsets. _query() regresa el resultid, true o false.</p>
 <p>Recomendacion para INFORMIX: Desabilita los cursores navegables 'scroll' con $db->cursorType = 0.
</p>

<p><a name=hack></a> </p>
<h2>Modfificando ADOdb con seguridad</h2>
<p>Tu puedes modificar ADOdb para tus propios usos. Por suerte puedes 
   mantener la compatibilidad extendiendo las clases de ADodb y por medio de la variable
   $ADODB_NEWCONNECTION.  $ADODB_NEWCONNECTION nos permite modificar el comportamiento de
   ADONewConnection().  ADOConnection() verifica esta variable e invocara la funcion cuyo
   nombre tenga la variable.
<p>En el siguiente ejemplo, se le agrega mas funcionabilidad al objeto de conexion por medio 
   de las clases <i>hack_mysql</i> y <i>hack_postgres7</i>. La convencion en el nombre de las
   clases recordset se controla por medio de la propiedad $rsPrefix. En este caso se le asigna
   el valor de 'hack_rs_', lo que proboca que ADOdb use <i>hack_rs_mysql</i> y 
   <i>hack_rs_postgres7</i> como los nombres de las clases recordset.
  En caso de que se requiera usar los drivers normales de ADODB hay que regresar el valor 'false'
   en la funcion.

<pre>
class hack_mysql extends adodb_mysql {
var $rsPrefix = 'hack_rs_';
  /* aqui van las modificaciones */
}

class hack_rs_mysql extends ADORecordSet_mysql {
 /* aqui van las modificaciones */
}

class hack_postgres7 extends adodb_postgres7 {
var $rsPrefix = 'hack_rs_';
 /* aqui van las modificaciones */
}

class hack_rs_postgres7 extends ADORecordSet_postgres7 {
 /* aqui van las modificaciones */
}

$ADODB_NEWCONNECTION = 'hack_factory';

function& hack_factory($driver)
{
	if ($driver !== 'mysql' && $driver !== 'postgres7') return false;
	
	$driver = 'hack_'.$driver;
	$obj = new $driver();
	return $obj;
}

include_once('adodb.inc.php');

</pre>
<p>No olvides invocar el constructor de la clase padre.
<a name="php5"></a>
<h2>Caracteristicas para PHP5</h2>
 A partir de la version 4.02 ADOdb determina automaticamente que version de PHP estas usando.
 Si detecta la version PHP5, activa automaticamente las siguientes caracteriticas:
<ul>
<li><b>PDO</b>: estan disponibles los drivers de PDO. Ve los <a href=#pdo>ejemplos de conexion</a>. Actualemte los drivers
   PDO no son tan poderosos como los drivers nativos, y deben de ser tomados como experimentales.<br><br>

<a name="php5iterators"></a>
<li><b>Foreach iterators</b>: Es una forma muy clara de procesar un 'recordset':
<pre>
	$ADODB_FETCH_MODE = ADODB_FETCH_NUM;
	$rs = $db->Execute($sql);
	foreach($rs as $k => $row) {
		echo "r1=".$row[0]." r2=".$row[1]."&lt;br>";
	}
</pre>
<p>
<a name="php5exceptions"></a>
<li><b>Exceptions</b>: Unicamente hay que incluir <i>adodb-exceptions.inc.php</i> y ya
   se pueden atrapar las excepciones conforme ocurran los errores.
<pre>
	<b>include("../adodb-exceptions.inc.php");</b> 
	include("../adodb.inc.php");	 
	try { 
		$db = NewADOConnection("oci8"); 
		$db->Connect('','scott','bad-password'); 
	} catch (exception $e) { 
		var_dump($e); 
	} 
</pre>
<p>Nota: Alcanzar el fin de archivo (EOF) <b>NO</b> es considerado ni un error ni una excepcion.
</ul> 
<h3><a name="drivers"></a>Bases de Datos soportadas</h3>
La columna <i>nombre</i> es el valor que se le pasa a NewADOConnection($nombre) para crear el objecto de conexion para
esa base de datos.
<table width="100%" border="1">
  <tr valign="top"> 
    <td><b>Nombre</b></td>
    <td><b>Verificada</b></td>
    <td><b>Base de datos</b></td>
    <td><b><font size="2">sirve RecordCount()</font></b></td>
    <td><b>Pre-requisitos</b></td>
    <td><b>Sistemas operativos</b></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">access</font></b></td>
    <td><font size="2">B</font></td>
    <td><font size="2">Microsoft Access/Jet. Hay que crear el DSN en el ODBC.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">ODBC </font></td>
    <td><font size="2">Windows unicamente</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">ado</font></b></td>
    <td><font size="2">B</font></td>
    <td><p><font size="2">ADO generico, no esta optimizado para ninguna base de datos 
        especifica. Permite conexiones DSN-less. Para un mejor rendimiento, utilizar un
        proveedor de OLEDB. Esta la clase basa para todos los drivers ado.</font></p>
      <p><font size="2">Hay que configurar $db-&gt;codePage antes de conextarse.</font></p></td>
    <td><font size="2">? depende de la base de datos</font></td>
    <td><font size="2">ADO o proveedor OLEDB</font></td>
    <td><font size="2">Windows unicamente</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">ado_access</font></b></td>
    <td><font size="2">B</font></td>
    <td><font size="2">Microsoft Access/Jet usando ADO. Permite conexiones DSN-less. 
      Para mejor rendimiento usar un proveedor OLEDB.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">ADO o proveedor OLEDB</font></td>
    <td><font size="2">Windows unicamente</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">ado_mssql</font></b></td>
    <td><font size="2">B</font></td>
    <td><font size="2">Microsoft SQL Server usando ADO. Permite conexiones DSN-less. 
      Para mejor rendimiento usar un proveedor OLEDB.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">ADO o proveedor OLEDB</font></td>
    <td><font size="2">Windows unicamente</font></td>
  </tr>
  <tr valign="top"> 
    <td height="54"><b><font size="2">db2</font></b></td>
    <td height="54"><font size="2">A</font></td>
    <td height="54"><font size="2">DB2. Debe de funcionar satisfactoriamente porque se base en el driver ODBC based on ODBC.</font></td>
    <td height="54"><font size="2">S/N</font></td>
    <td height="54"><font size="2">Interfase CLI/ODBC de DB2</font></td>
    <td height="54"> <p><font size="2">Unix y Windows. <a href="http://www.faqts.com/knowledge_base/view.phtml/aid/6283/fid/14">Trucos de instalacion en Unix</a>. 
    Hay reportes de que los parametros $host y $database del Connect() tienen que ir invertidos si se usa la interfase CLI.</font></p></td>
  </tr>
  <tr valign="top"> 
    <td height="54"><b><font size="2">odbc_db2</font></b></td>
    <td height="54"><font size="2">C</font></td>
    <td height="54"><font size="2">Se conecta a DB2 usando la extesion ODBC generica.</font></td>
    <td height="54"><font size="2">S/N</font></td>
    <td height="54"><font size="2">Interfase CLI/ODBC de DB2</font></td>
    <td height="54"> <p><font size="2">Unix y Windows. <a href="http://www.faqts.com/knowledge_base/view.phtml/aid/6283/fid/14">sugerencias para instalacion en Unix</a>. Tengo reportes que los parametros $host y $database tienen que ser invertidos en el Connect() cuando se usa la interfase CLI.</font></p></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">vfp</font></b></td>
    <td><font size="2">A</font></td>
    <td><font size="2">Microsoft Visual FoxPro. Hay que crear un DSN.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">ODBC</font></td>
    <td><font size="2">Windows unicamente</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">fbsql</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">FrontBase. </font></td>
    <td><font size="2">S</font></td>
    <td><font size="2">?</font></td>
    <td> <p><font size="2">Unix y Windows</font></p></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">ibase</font></b></td>
    <td><font size="2">B</font></td>
    <td><font size="2">Interbase 6 o anterior. Algunos usuarios dicen que puedes necesitar esta sintaxis para conectarte<br>
      $db->PConnect('localhost:c:/ibase/employee.gdb', "sysdba", "masterkey") 
      . Actualmente le falta Affected_Rows.<br>
      <br>
      Antes de conectarte puedes modificarle $db->dialect, $db-&gt;buffers y $db->charSet.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">cliente Interbase</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><i><font size="2">firebird</font></i></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">version Firebird de interbase.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">cliente Interbase</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><i><font size="2">borland_ibase</font></i></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">version Borland de Interbase 6.5 o posterior. Desafortunadamente las
      version son diferentess.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">cliente Interbase</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">informix72</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Versiones Informix anteriores a 7.3 que no soportan
      SELECT FIRST.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente Informix</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">informix</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Driver generico para informix.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente Informix</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">ldap</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Driver LDAP driver. Ver el ejemplo para informacion de uso.</font></td>
    <td>&nbsp;</td>
    <td><font size="2">Extension LDAP</font></td>
    <td><font size="2">?</font></td>
  </tr>
  <tr valign="top"> 
    <td height="73"><b><font size="2">mssql</font></b></td>
    <td height="73"><font size="2">A</font></td>
    <td height="73"> <p><font size="2">Microsoft SQL Server 7 y posterior. Tanbien funciona
        con Microsoft SQL Server 2000. Toma en cuenta que el formato de las fechas es
        problematico con este driver. Por ejemplo, la extension mssql de PHP no regresa
        los segundos de los campos datetime!</font></p></td>
    <td height="73"><font size="2">S/N</font></td>
    <td height="73"><font size="2">cliente Mssql</font></td>
    <td height="73"> <p><font size="2">Unix y Windows. <br>
        <a href="http://phpbuilder.com/columns/alberto20000919.php3">Guia de instalacion de Unix
        </a> y <a href=http://linuxjournal.com/article.php?sid=6636&mode=thread&order=0>otra mas</a>. </font></p></td>
  </tr>
  <tr valign="top"> 
    <td height="73"><b><font size="2">mssqlpo</font></b></td>
    <td height="73"><font size="2">A</font></td>
    <td height="73"> <p><font size="2">Driver portable de mssql. Es identico al driver de
        mssqk anteriorm excepto que el operador de concatenacion '||' se convirtio a '+'.
        Esto es util para migrar codigo desde otras versiones de SQL.</font></p></td>
    <td height="73"><font size="2">S/N</font></td>
    <td height="73"><font size="2">Cliente Mssql</font></td>
    <td height="73"> <p><font size="2">Unix y Windows. <a href="http://phpbuilder.com/columns/alberto20000919.php3"><br>Guia de instlacion en Unix</a>.</font></p></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">mysql</font></b></td>
    <td><font size="2">A</font></td>
    <td><font size="2">MySQL sin manejo de transacciones. 
       Puedes usar $db-&gt;clientFlags antes de conectarte.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente MySQL</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><font size="2"><b>mysqlt</b> or <b>maxsql</b></font></td>
    <td><font size="2">A</font></td>
    <td> <p><font size="2">MySQL con soporte de transacciones. Recomendamos usar
        || como el operador de concatenacion para una mejor portabilidad.
        Esto se logra ejectuando MySQL con: <br>
        <i>mysqld --ansi</i> o <i>mysqld --sql-mode=PIPES_AS_CONCAT</i></font></p></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente MySQL</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">oci8</font></b></td>
    <td><font size="2">A</font></td>
    <td><font size="2">Oracle 8/9. Tiene mas funcionabilidad que el driver <i>oracle</i> 
      (ej. Affected_Rows). Puedes tener que hacer un putenv('ORACLE_HOME=...') antes del 
      Connect/PConnect. </font> <p><font size="2"> hay dos maneras de conectarse
        - Con la direccion IP del servidor y el nombre del servicio: <br>
        <i>PConnect('serverip:1521','scott','tiger','service'</i>)<br>
        o en base a un renglon en TNSNAMES.ORA o ONAMES o HOSTNAMES: <br>
        <i>PConnect(false, 'scott', 'tiger', $oraname)</i>. </font> 
      <p><font size="2">A partir de la version 2.31, se manejan las variables de cursores REF 
        directamente (ver <a href="#executecursor">ExecuteCursor</a>).</font> </td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente Oracle</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">oci805</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Maneja un funcionaldiad reducida para la version 8.0.5 de Oracle.
      SelectLimit no es tan eficiente como en los drivers oci8 o oci8po.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente Oracle</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">oci8po</font></b></td>
    <td><font size="2">A</font></td>
    <td><font size="2">Driver portable de Oracle 8/9. Esta es casi identica al driver oci8 
    execpto que (a) Las variables 'bind' en los Prepare() usan ? en lugar de :bindvar,
    (b) los nombres de campos estan en minusculas (la manera mas usual en PHP). </font> 
    <p><font size="2">Usa este driver si la portabilidad de tu codigo a otras bases de datos
    es importante. En caso contrario usa el driver oci8 ya que da mejor rendimiento. </font> </td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente Oracle</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">odbc</font></b></td>
    <td><font size="2">A</font></td>
    <td><font size="2">Driver generico para ODBC, no esta optimizado para ninguna base de
    datos especifica. Para conectarse usa <br>
      PConnect('DSN','user','pwd'). Esta es la clase base para todos los drivers basados en ODBC
      .</font></td>
    <td><font size="2">? depende de la base de datos</font></td>
    <td><font size="2">ODBC</font></td>
    <td><font size="2">Unix y Windows. <a href="http://phpbuilder.com/columns/alberto20000919.php3?page=4">Trucos para Unix.</a></font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">odbc_mssql</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Usa ODBC para conectarse a MSSQL</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">ODBC</font></td>
    <td><font size="2">Unix y Windows. </font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">odbc_oracle</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Usa ODBC para conectarse a Oracle</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">ODBC</font></td>
    <td><font size="2">Unix y Windows. </font></td>
  </tr>
    
  <tr valign="top"> 
    <td><b><font size="2">odbtp</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Driver odbtp generico. 
    <a href=http://odbtp.sourceforge.net/>Odbtp</a> es un programa para poder usar los
    DSN en el ODBC de Windows desde OTROS sistemas operativos (ej. Linux).</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">odbtp</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">odbtp_unicode</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Odtbp con soporte unicode</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">odbtp</font></td>
    <td><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td height="34"><b><font size="2">oracle</font></b></td>
    <td height="34"><font size="2">C</font></td>
    <td height="34"><font size="2">Implementa el viejo API de Oracle 7. Si te es posible
      usa el driver oci8 para un mejor rendimiento.</font></td>
    <td height="34"><font size="2">S/N</font></td>
    <td height="34"><font size="2">Cliente Oracle</font></td>
    <td height="34"><font size="2">Unix y Windows</font></td>
  </tr>
  <tr valign="top"> 
    <td height="34"><b><font size="2">netezza</font></b></td>
    <td height="34"><font size="2">C</font></td>
    <td height="34"><font size="2">Driver para Netezza. Netezza esta basado en el codigo
       base de postgres.</font></td>
    <td height="34"><font size="2">Y</font></td>
    <td height="34"><font size="2">?</font></td>
    <td height="34"><font size="2">?</font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">postgres</font></b></td>
    <td><font size="2">A</font></td>
    <td><font size="2">Driver generico PostgreSQL. 
        Actualmente es identico al driver postgres7. </font></td>
    <td><font size="2">S</font></td>
    <td><font size="2">Cliente PostgreSQL</font></td>
    <td><font size="2">Unix y Windows. </font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">postgres64</font></b></td>
    <td><font size="2">A</font></td>
    <td><font size="2">Para PostgreSQL 6.4 y anteriores que no manejan LIMIT internamente.</font></td>
    <td><font size="2">S</font></td>
    <td><font size="2">Cliente PostgreSQL</font></td>
    <td><font size="2">Unix y Windows. </font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">postgres7</font></b></td>
    <td><font size="2">A</font></td>
    <td><font size="2">PostgreSQL que soporta LIMIT y caracteristicas de la version 7.</font></td>
    <td><font size="2">S</font></td>
    <td><font size="2">Cliente PostgreSQL</font></td>
    <td><font size="2">Unix y Windows. </font></td>
  </tr>
    <tr valign="top"> 
    <td><b><font size="2">postgres8</font></b></td>
    <td><font size="2">A</font></td>
    <td><font size="2">PostgreSQL que maneja la funcionalidad de la version 8.</font></td>
    <td><font size="2">S</font></td>
    <td><font size="2">Cliente PostgreSQL</font></td>
    <td><font size="2">Unix y Windows. </font></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">sapdb</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">SAP DB. 
    Debe de funcionar bien ya que esta basado en el driver ODBC.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente ODBC de SAPdb</font></td>
    <td> <p><font size="2">?</font></p></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">sqlanywhere</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Sybase SQL Anywhere. 
    Debe de funcionar bien ya que esta basado en el driver ODBC.</font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente ODBC de SQL Anywhere ODBC</font></td>
    <td> <p><font size="2">?</font></p></td>
  </tr>
  <tr valign="top"> 
    <td height="54"><b><font size="2">sqlite</font></b></td>
    <td height="54"><font size="2">B</font></td>
    <td height="54"><font size="2">SQLite. Unicamente verificada en PHP5.</font></td>
    <td height="54"><font size="2">S</font></td>
    <td height="54"><font size="2">-</font></td>
    <td height="54"> <p><font size="2">Unix y Windows.</font></p></td>
  </tr>
  <tr valign="top"> 
    <td height="54"><b><font size="2">sqlitepo</font></b></td>
    <td height="54"><font size="2">B</font></td>
    <td height="54"><font size="2">Driver portable para SQLLite. Es debido a que el modo asociativo no funciona como en
    los otros drivers.  Al seleccionar multiples tablas (joining), se incluye el nombre de la tabla en la llave del
    arreglo asociativo.</font><p>
<font size="2">   En el driver "sqlitepo", el nombre de la tabla es eliminado del nombre de la columna. 
Cuando hay conflictos, el primer campo tiene preferencia.
      </font></p></td>
    <td height="54"><font size="2">S</font></td>
    <td height="54"><font size="2">-</font></td>
    <td height="54"> <p><font size="2">Unix y Windows.</font></p></td>
  </tr>
  <tr valign="top"> 
    <td><b><font size="2">sybase</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Sybase. </font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente Sybase</font></td>
    <td> <p><font size="2">Unix y Windows.</font></p></td>
  </tr>
 <tr valign="top"> 
    <td><b><font size="2">sybase_ase</font></b></td>
    <td><font size="2">C</font></td>
    <td><font size="2">Sybase ASE. </font></td>
    <td><font size="2">S/N</font></td>
    <td><font size="2">Cliente Sybase</font></td>
    <td> <p><font size="2">Unix y Windows.</font></p></td>
  </tr>
  <p> 
</table>

<p>La columna &quot;Verificada&quot; indica que tan profusamente el codigo a sido verificado y usado.<br>
  A = bien verificado y usado con mucha gente<br>
  B = verificado y usable, pero algunas caracteristicas pueden no estar implementadas<br>
  C = driver proporcionado por los usuarios o experimental.
      Puede no manejar todas las ultimas caracteristcicas de ADOdb. </p>
<p>La columna &quot;sirve RecordCount()&quot; indica si RecordCount() 
  regresa la cantidad de renglones o regresa -1 cuando se ejectuta un enunciado SELECT. 
  Si la columna muestra S/N entonces RecordCount() es simulado cuando la variable global
  $ADODB_COUNTRECS=true (esto es el valor por omision). Nota que para recordsets muy grandes, 
  puede ser mejor desabilitar la emulacion de RecordCount()debido a la gran cantidad de
  memoria para leer el recordset para contarlo. Tambien hay una penalizacion del 40-50%
  si se tiene que emular la funcion. Es emulada en la mayoria de las bases de datos excepto para
  PostgreSQL y MySQL. Esta variable es verificada cada vez que se ejecuta un SELECT, por lo
  que puedes escoger selectivamente cuales recordset contar.</p>
<p> 
<hr>
<h1>Tutoriales<a name="quickstart"></a></h1>
<h3>Ejemplo 1: SELECT<a name="ex1"></a></h3>
<p>Tarea: Conectarse al DSN MS Access de la base de datos Nortwind, mostrar las primeras
  2 columnas de cada renglon.</p>
<p>En este ejemplo, se crea un objeto ADOConnection que representa la conexion 
  a la base de datos. La conexion se inicia con <a href="#pconnect"><font face="Courier New, Courier, mono">PConnect</font></a>, 
  que es una conexion persistente. Para interrogar a las base de datos llamamos a la funcion
  <font face="Courier New, Courier, mono">ADOConnection.<a href="#execute">Execute</a>()</font> 
  . Esto regresa un objeto ADORecordSet que es de hecho un cursor que contiene el 
  renglon actual en el arreglo <font face="Courier New, Courier, mono">fields[]</font>. 
  Tambien usamos el metodo <font face="Courier New, Courier, mono">
  <a href="#movenext">MoveNext</a>()</font> para avanzar de renglon en renglon.</p>
<p>Nota: Una funcion muy util que NO usamos en este ejemplo es 
   <font face="Courier New, Courier, mono"><a href="#selectlimit">SelectLimit</a></font>, 
   que nos permite limitar la cantidad de renglones a mostrar. 
<pre>
&lt;?
<font face="Courier New, Courier, mono"><b>include</b>('adodb.inc.php');	   # Carga el codigo comun de ADOdb
$<font color="#660000">conn</font> = &amp;ADONewConnection('access');	# crea la conexion
$<font color="#660000">conn</font>->PConnect('northwind');   # se conecta a la base detos northwind via el DSN MS-Access
$<font color="#660000">recordSet</font> = &amp;$<font color="#660000">conn</font>->Execute('select * from products');
if (!$<font color="#660000">recordSet</font>) 
	print $<font color="#660000">conn</font>-&gt;ErrorMsg();
else
<b>while</b> (!$<font color="#660000">recordSet</font>-&gt;EOF) &#123;
	<b>print</b> $<font color="#660000">recordSet</font>->fields[0].' '.$<font color="#660000">recordSet</font>->fields[1].'&lt;BR&gt;';
	$<font color="#660000">recordSet</font>-&gt;MoveNext();
&#125;</font><font face="Courier New, Courier, mono">

$<font color="#660000">recordSet</font>->Close(); # opcional
$<font color="#660000">conn</font>->Close(); # opcional
</font>
?>
</pre>
<p>La variable $<font face="Courier New, Courier, mono">recordSet</font> obtenida contiene
  el renglon actual en el arreglo <font face="Courier New, Courier, mono">$recordSet-&gt;fields</font> 
  , indexado por numero de columna (empezando en cero). Usamos el metodo <font face="Courier New, Courier, mono"><a href="#movenext">MoveNext</a>()</font> 
  para avanxar al renglon siguiente. La propiedad  <font face="Courier New, Courier, mono">EOF</font> 
  tiene valor verdadero (true) cuando se llega al final del archivo. Si hay algun error en
  el Execute() se regresa falso (false) en lugar del recordset.</p>
<p>El arreglo <code>$recordSet-&gt;fields[]</code> es generado por la extension PHP de la base
   de datos correspondiente. Algunas extensiones unicamente indexan por numero y no por nombre
   del campo. Para provocar que se indexe por nombre (o sea con arreglos asociativos)
   hay que usar la  funcion SetFetchMode. Cada recordset almacena y usa el metodo que estuvo
   vigente cuando se creo el recordset con un Execute() o SelectLimit().
<pre>
	$db->SetFetchMode(ADODB_FETCH_NUM);
	$rs1 = $db->Execute('select * from table');
	$db->SetFetchMode(ADODB_FETCH_ASSOC);
	$rs2 = $db->Execute('select * from table');
	print_r($rs1->fields); # muestra <i>array([0]=>'v0',[1] =>'v1')</i>
	print_r($rs2->fields); # muestra <i>array(['col1']=>'v0',['col2'] =>'v1')</i>
</pre>
<p> </p>
<p>Para obtener el numero de renglones en el enunciado SELECT, se puede usar la funcion 
   <font face="Courier New, Courier, mono">$recordSet-&gt;<a href="#recordcount">RecordCount</a>()</font>. 
  Observa que la funcion puede regresar -1 si no se puede determinar la cantidad de renglones.</p>
<h3>Ejemplo 2: SELECT Avanzado con objetos de campos<a name="ex2"></a></h3>
<p>Seleccionar los registros de una tabla, desplegar las primeras dos columnas. Si la segunda
   columna es un campo DATE o TIMESTAMP entonces reformatear la fecha al formato americano.</p>
<pre>
&lt;?php
<font face="Courier New, Courier, mono"><b>include</b>('adodb/adodb.inc.php');	   # Carga el codigo comun de ADOdb
$<font color="#660000">conn</font> = &amp;ADONewConnection('access');	# crea la conexion
$<font color="#660000">conn</font>->PConnect('northwind');   # se conecta al DSN de northwind 
$<font color="#660000">recordSet</font> = &amp;$<font color="#660000">conn</font>->Execute('select CustomerID,OrderDate from Orders');
if (!$<font color="#660000">recordSet</font>) 
	print $<font color="#660000">conn</font>-&gt;ErrorMsg();
else
<b>while</b> (!$<font color="#660000">recordSet</font>-&gt;EOF) &#123;
	$<font color="#660000">fld</font> = <font color="#336600"><b>$</b><font color="#660000">recordSet</font><b>-&gt;FetchField</b></font><font color="#006600">(</font>1<font color="#006600">);</font>
	$<font color="#660000">type</font> = <font color="#336600"><b>$</b><font color="#660000">recordSet</font><b>-&gt;MetaType</b></font>($fld-&gt;type);

	<b>if</b> ( $<font color="#660000">type</font> == 'D' || $<font color="#660000">type</font> == 'T') 
		<b>print</b> $<font color="#660000">recordSet</font>-&gt;fields[0].' '.
			<b><font color="#336600">$</font></b><font color="#660000">recordSet</font><b><font color="#336600">-&gt;UserDate</font></b>($<font color="#660000">recordSet</font>-&gt;fields[1],'<b>m/d/Y</b>').'&lt;BR&gt;';
	<b>else </b>
		<b>print</b> $<font color="#660000">recordSet</font>->fields[0].' '.$<font color="#660000">recordSet</font>->fields[1].'&lt;BR&gt;';

	$<font color="#660000">recordSet</font>-&gt;MoveNext();
&#125;</font><font face="Courier New, Courier, mono">
$<font color="#660000">recordSet</font>->Close(); # opcional
$<font color="#660000">conn</font>->Close(); # opcional
</font>
?>
</pre>
<p>En este ejemplo se verifica el tipo de campo de la segunda columna usando la funcion 
  <font face="Courier New, Courier, mono"><a href="#fetchfield">FetchField</a>().</font> 
  Esto obtiene un objeto con al menos tres propiedades.</p>
<ul>
  <li><b>name</b>: Nombre de la columna (campo)</li>
  <li> <b>type</b>: Tipo nativo del campo de la columna</li>
  <li> <b>max_length</b>: Longitid maxima del campo. Algunas bases de datos como MySQL 
    no regresan la longitud maxima del campo adecuadamente. En estos casos max_length contendra -1.</li>
</ul>
<p>Posteriormente usamos <font face="Courier New, Courier, mono"><a href="#metatype">MetaType</a>()</font> 
  para traducir el tipo nativo a un tipo <i>generico</i>. Actualmente estan definidos los
  siguientes tipos <i>genericos</i>:</p>
<ul>
  <li><b>C</b>: Campo caracter que se debe de mostrar en etiquetas 
     &lt;input type=&quot;text&quot;&gt;.</li>
  <li><b>X</b>: TeXtos, campos de texto largo (indefinido) que se deben de mostrar en &lt;textarea&gt;</li>
  <li><b>B</b>: Blobs, u Objectos Binarios Largos (BYTE). Normalmente son imagenes. 
  <li><b>D</b>: Campo fecha</li>
  <li><b>T</b>: Campo Timestamp o datetime</li>
  <li><b>L</b>: Campo logico (boleano o de bit)</li>
  <li><b>I</b>:&nbsp; Campo entero</li>
  <li><b>N</b>: Campo numerico. Incluye auto incrementales (seriales), numericos, punto flotante,
    reales y enteros.</li>
  <li><b>R</b>: Campo serial. Incluye serial, enteros auto incrementales integers. Funciona solo para algunas bases de datos. </li>
</ul>
<p>Si el metatype es de tipo date o timestamp, entonces se imprime usando la funcion definida por
   el usuario <font face="Courier New, Courier, mono"><a href="#userdate">UserDate</a>(),</font> 
  la cual convierte la cadena de texto en formato PHP SQL al formato definido por el usuario.
  otro uso para la funcion <font face="Courier New, Courier, mono"><a href="#metatype">MetaType</a>()</font> 
  es para validar los datos antes de ejecutar un enunciado SQL de INSERT o UPDATE.</p>
<h3>Ejemplo 3: Insert<a name="ex3"></a></h3>
<p>Insertar un renglon en la tabla Orders conteniendo fechas y cadenas de caracteres que
   necesitan ser encomillados antes de que sean aceptados por la base de datos, por ejemplo el
   apostrofo en la palabra <i>John's</i>.</p>
<pre>
&lt;?php
<b>include</b>('adodb/adodb.inc.php');	   # carga el codigo comun de ADOdb
$<font color="#660000">conn</font> = &amp;ADONewConnection('access');	# crea la connection

$<font color="#660000">conn</font>->PConnect('northwind');   # Se conecta al DSN northwind 
$<font color="#660000">shipto</font> = <font color="#006600"><b>$conn-&gt;qstr</b></font>(&quot;<i>John's Old Shoppe</i>&quot;);

$<font color="#660000">sql</font> = &quot;insert into orders (customerID,EmployeeID,OrderDate,ShipName) &quot;;
$<font color="#660000">sql</font> .= &quot;values ('ANATR',2,&quot;.<b><font color="#006600">$conn-&gt;DBDate(</font>time()<font color="#006600">)</font></b><font color="#006600">.</font>&quot;,$<font color="#660000">shipto</font>)&quot;;

<b>if</b> ($<font color="#660000">conn</font>->Execute($<font color="#660000">sql</font>) <font color="#336600"><b>=== false</b></font>) &#123;
	<b>print</b> 'error al insertar: '.<font color="#336600"><b>$conn-&gt;ErrorMsg()</b></font>.'&lt;BR&gt;';
&#125;
?>
</pre>
<p>En este ejemplo observamos el manejo avanzado de encomillado y de fechas que tiene 
  ADOdb. El valor unix del tiempo (que es un entero largo) se formatea correctamente para
  Access con <font face="Courier New, Courier, mono"><a href="#dbdate">DBDate</a>()</font>, 
  y se usa el caracter adecuado para encomillar <i>John's Old Shoppe</i>, 
  lo correcto es <b> </b><i>John'<b>'</b>s Old Shoppe</i> y no lo que hace PHP normalmente
  <i>John<b>'</b>s Old Shoppe</i> con <font face="Courier New, Courier, mono"><a href="#qstr">qstr</a>()</font>. 
</p>
<p>Observa el manejo de errores en el enunciado Execute. Se obtiene Falso si hubo un error
  al ejectutar <font face="Courier New, Courier, mono"><a href="#execute">Execute</a>().
  </font> El mensaje de error del ultimo error encontrado se muestra con
  <font face="Courier New, Courier, mono"><a href="#errormsg">ErrorMsg</a>()</font>. 
  Ojo: Se necesita que <i>php_track_errors</i> este habiliatado para que se salven los mensajes
  de error.</p>
<h3> Ejemplo 4: Depurando<a name="ex4"></a></h3>
<pre>&lt;?php
<b>include</b>('adodb/adodb.inc.php');	   # carga el codigo comun de ADOdb
$<font color="#663300">conn</font> = &amp;ADONewConnection('access');	# crea la conexion
$<font color="#663300">conn</font>->PConnect('northwind');   # se conecta al DSN de northwind
$<font color="#663300">shipto</font> = <b>$conn-&gt;qstr</b>(&quot;John's Old Shoppe&quot;);
$<font color="#663300">sql</font> = &quot;insert into orders (customerID,EmployeeID,OrderDate,ShipName) &quot;;
$<font color="#663300">sql</font> .= &quot;values ('ANATR',2,&quot;.$<font color="#663300">conn</font>-&gt;FormatDate(time()).&quot;,$shipto)&quot;;
<b><font color="#336600">$<font color="#663300">conn</font>-&gt;debug = true;</font></b>
<b>if</b> ($<font color="#663300">conn</font>->Execute($sql) <b>=== false</b>) <b>print</b> 'error inserting';</font>
?&gt;
</pre>
<p>En el ejemplo anterior  se activo la depuracion asignando <b>debug = true</b>. 
  Esto desplegara los enunciados SQL antes de ejectuarse, y ademas mostrara cualquier mensaje
  de error. En este caso no hay necesidad de llamar la funcion 
  <font face="Courier New, Courier, mono"><a href="#errormsg">ErrorMsg</a>()</font>. 
  Para mostrar el contenido del recordset, ve el ejemplo de 
  <font face="Courier New, Courier, mono"><a href="#exrs2html">rs2html</a>()</font>.</p>
<p>Tambien ve la seccion de <a href=#errorhandling>Manejadores de error a la medida</a>.</p>
<h3>Ejemplo 5: MySQL y Menus<a name="ex5"></a></h3>
<p>Conectarse a la base de datos MySQL <i>agora</i>, y generar un menu &lt;select&gt;  
  a partir de un enunciado SQL donde cada leyenda del &lt;option&gt; se saca de la primera
  columna y el valor a enviar al servidor se obtiene de la segunda columna.</p>
<pre>&lt;?php
<b>include</b>('adodb/adodb.inc.php'); # Carga el codigo comun de ADOdb
$<font color="#663300">conn</font> = &amp;ADONewConnection('mysql');  # crea la conexion
$<font color="#663300">conn</font>->PConnect('localhost','userid','','agora');# se conecta a la base de datos agora
<font color="#000000">$<font color="#663300">sql</font> = 'select CustomerName, CustomerID from customers';
$<font color="#663300">rs</font> = $<font color="#663300">conn</font>->Execute($sql);
<b>print</b> <b><font color="#336600">$<font color="#663300">rs</font>-&gt;GetMenu('GetCust','Mary Rosli');
?&gt;</font></b></font></pre>
<p>Aqui definimos un menu llamado GetCust, con la opcion del menu 'Mary Rosli' pre seleccionada. 
  Ve el metodo <a href="#getmenu"><font face="Courier New, Courier, mono">GetMenu</font></a><font face="Courier New, Courier, mono">()</font>. 
  Tambien hay funciones que regresan el recordset como un arreglo: <font face="Courier New, Courier, mono"><a href="#getarray">GetArray</a>()</font>, 
  y como un arreglo asociativo con la primera columna como llave: <a href="#getassoc1">GetAssoc</a>().</p>
<h3>Ejemplo 6: Conectarse a dos bases de datos al mismo tiempo<a name="ex6"></a></h3>
<pre>&lt;?php
<b>include</b>('adodb/adodb.inc.php');	 # Carga el codigo comun de ADOdb
$<font color="#663300">conn1</font> = &amp;ADONewConnection('mysql');  # Crea la conexion a mysql
$<font color="#663300">conn2</font> = &amp;ADONewConnection('oracle');  # Crea la conexion a oracle

$conn1-&gt;PConnect($server, $userid, $password, $database);
$conn2-&gt;PConnect(false, $ora_userid, $ora_pwd, $oraname);

$conn1-&gt;Execute('insert ...');
$conn2-&gt;Execute('update ...');
?&gt;</pre>
<p> 
<h3>Ejemplo 7: Generando enunciados SQL de Update e Insert<a name="ex7"></a></h3>
<p>Desde la version 4.56 de ADOdb,manejamos <a href="#autoexecute">AutoExecute()</a>, 
el cual simplifica las cosas proporcionando una funcion de nivel superior que encapsula los llamados a GetInsertSQL() y
 GetUpdateSQL(). Por ejemplo, un INSERT puede hacerse asi:

<pre>
    $record["firstname"] = "Bob"; 
    $record["lastname"] = "Smith"; 
    $record["created"] = time(); 
    $insertSQL = $conn->AutoExecute($rs, $record, 'INSERT'); 
</pre>

y un UPDATE asi:
<pre>
    $record["firstname"] = "Caroline"; 
    $record["lastname"] = "Smith"; # Actualiza iel apellido de Caroline de Miranda a Smith 
    $insertSQL = $conn->AutoExecute($rs, $record, 'UPDATE', 'id = 1'); 
</pre>
<p>El resto de esta section esta desactualizada:
<p>A partir de la version 1.31 de ADOdb 1.31 hay dos metodos nuevos para recordset: 
 GetUpdateSQL( ) y GetInsertSQL( ). Esto nos permite ejecutar un "SELECT * FROM table query WHERE...", 
copiar los valores de $rs->fields, modificar los campos y generar el SQL correcto para hacer
un update o insert en la tabla.
<p> Mostraremos como pueden ser empleadas las funciones en una tabla con los siguiente campos:
  (ID, FirstName, LastName, Created). 
<p> Antes de que estos metodos puedan ser invocados, necesitas inicializar el recordset
 ejecutando un select en la tabla. En base a una idea de Jonathan Younger jyounger#unilab.com. 
 a partir de la version de 2.42 de ADOdb, puedes mandar como parametro el nombre de la tabla
 en lugar del recordset y se generara un enunciado insert para la tabla.
<p> 
<pre>&lt;?php
#=====================================================
# codigo de Ejemplo de GetUpdateSQL()y GetInsertSQL() 
#=====================================================
include('adodb/adodb.inc.php');
include('adodb/tohtml.inc.php');

#==========================
# Codigo para probar un insert

$sql = "SELECT * FROM ADOXYZ WHERE id = -1"; 
# Selecciona un registro en blanco de la base de datos

$conn = &ADONewConnection("mysql");  # crea la conexion
$conn->debug=1;
$conn->PConnect("localhost", "admin", "", "test"); # se conecta a la base de datos testdb
$rs = $conn->Execute($sql); # Ejecuta la busqueda y obtiene el recordset vacio

$record = array(); # Inicializa el arreglo que contiene los datos a insertar

# Asignar el valor de los campos en el registro
# Observa que el nombre de los campos pueden ser mayusculas o minusculas
$record["firstname"] = "Bob";
$record["lastNamE"] = "Smith";
$record["creaTed"] = time();

# Mandar como parametro el recordset vacio y el arreglo conteniendo los datos a insertar
# a la funcion GetInsertSQL. Esta procesara los datos y regresara un enunciado SQL
# para procesar el INSERT.
$insertSQL = $conn->GetInsertSQL($rs, $record);

$conn->Execute($insertSQL); # Inserta el registro en la base de datos

#==========================
# Codigo de prueba para UPDATE

$sql = "SELECT * FROM ADOXYZ WHERE id = 1"; 
# Selecciona el registro a actualizar

$rs = $conn->Execute($sql); # Executa la busqueda y obtiene el registro a actualizar.

$record = array(); # Inicializa el arreglo que contiene los datos a modificar

# Asignar el valor de los campos en el registro
# Observa que el nombre de los campos pueden ser mayusculas o minusculas
$record["firstname"] = "Caroline";
$record["LasTnAme"] = "Smith"; # Corrige el apellido de Carolina de Miranda a Smith

# Mandar como parametro el recordset y el arreglo conteniendo los datos a actualizar
# a la funcion GetUpdateSQL. Esta procesara los datos y regresara el enunciado sql del
# update necesario con clausula WHERE correcta.
# Si no se modificaron los datos no regresa nada.
$updateSQL = $conn->GetUpdateSQL($rs, $record);

$conn->Execute($updateSQL); # Actualiza el registro en la base de datos
$conn->Close();
?>
</pre>
<a name="ADODB_FORCE_TYPE"></a>
<b>$ADODB_FORCE_TYPE</b><p>
El comportamiento de AutoExecute(), GetUpdateSQL() y GetInsertSQL() al convertir variables PHP vacias o nulas a varibales SQL
is controlado por la nueva variable global $ADODB_FORCE_TYPE. Asignale alguno de los valores enlistados abajo. El valor por 
omision es ADODB_FORCE_VALUE (3):
</p><pre>0 = ignorar campos vacios. Todos los campos vacios en el arreglo son ignorados.
1 = forzar null. Todos los campos vacios, con valor null (de php) o con la cadena 'null' se cambian al 
    valor SQL de NULL.
2 = forzar vacio. Todos los campos vacios, con valor null (de php) o con la cadena 'null' se cambian a la 
    cadena vacia de SQL '' o a 0.
3 = forzar valor value. El valor se deja como esta. Lo null (de php) y las cadenas 'null' se cambien a NULL 
    de SQL y los camnpos vacios con '' se convierten a vacio de SQL ''. 

define('ADODB_FORCE_IGNORE',0);
define('ADODB_FORCE_NULL',1);
define('ADODB_FORCE_EMPTY',2);
define('ADODB_FORCE_VALUE',3);
</pre>
<p>
Gracias a Niko (nuko#mbnet.fi) por el codigo de $ADODB_FORCE_TYPE.
</p><p>
Nota: la constante ADODB_FORCE_NULLS es obsoleta desde la version 4.52 y es ignorada. Asigna $ADODB_FORCE_TYPE = ADODB_FORCE_NULL para un comportamiento similar.
<p>Desde la version 4.62, el nombre de la tabla a ser usada puede ser modificado al poner $rs->tableName antes de invocar
 AutoExecute(), GetInsertSQL() o GetUpdateSQL().
</p>
<h3>Ejemplo 8: Implementando cursores con Siguiente y Anterior<a name="ex8"></a></h3>
<p> El siguiente codigo crea un navegador por paginas muy sencillo, donde puedes navegar de
  pagina en pagina de un recordset.</p>
<pre>&lt;?php
include_once('adodb/adodb.inc.php');
include_once('adodb/adodb-pager.inc.php');
session_start();

$db = NewADOConnection('mysql');

$db->Connect('localhost','root','','xphplens');

$sql = "select * from adoxyz ";

$pager = new ADODB_Pager($db,$sql);
$pager->Render($rows_per_page=5);
?>
</pre>

<p>Esto crea un paginador de registros que es asi: <a name="scr"></a> 
<p> 
<table border=1 bgcolor=beige>
  <tr> 
    <td> <a href="#scr"><code>|&lt;</code></a> &nbsp; <a href="#scr"><code>&lt;&lt;</code></a> 
      &nbsp; <a href="#scr"><code>>></code></a> &nbsp; <a href="#scr"><code>>|</code></a> 
      &nbsp; </td>
  </tr>
  <tr>
    <td><TABLE COLS=4 width=100% border=1 bgcolor=white>
        <TH>ID</TH>
        <TH>First Name</TH>
        <TH>Last Name</TH>
        <TH>Date Created</TH>
        <TR> 
          <TD align=right>36&nbsp;</TD>
          <TD>Alan&nbsp;</TD>
          <TD>Turing&nbsp;</TD>
          <TD>Sat 06, Oct 2001&nbsp;</TD>
        </TR>
        <TR> 
          <TD align=right>37&nbsp;</TD>
          <TD>Serena&nbsp;</TD>
          <TD>Williams&nbsp;</TD>
          <TD>Sat 06, Oct 2001&nbsp;</TD>
        </TR>
        <TR> 
          <TD align=right>38&nbsp;</TD>
          <TD>Yat Sun&nbsp;</TD>
          <TD>Sun&nbsp;</TD>
          <TD>Sat 06, Oct 2001&nbsp;</TD>
        </TR>
        <TR> 
          <TD align=right>39&nbsp;</TD>
          <TD>Wai Hun&nbsp;</TD>
          <TD>See&nbsp;</TD>
          <TD>Sat 06, Oct 2001&nbsp;</TD>
        </TR>
        <TR> 
          <TD align=right>40&nbsp;</TD>
          <TD>Steven&nbsp;</TD>
          <TD>Oey&nbsp;</TD>
          <TD>Sat 06, Oct 2001&nbsp;</TD>
        </TR>
      </TABLE></td>
  </tr>
  <tr>
    <td><font size=-1>Page 8/10</font></td>
  </tr>
</table>
<p>El numero de renglones a mostrar en cada pagina se controla con el metodo Render($rows).
  Si no le mandas ningun parametro a Render(), ADODB_Pager toma como valor por omision
  10 renglones por pagina. 
<p>Puedes controlar el titulo de cada columna modificando el SQL (funciona en la mayoria
  de las bases de datos):
<pre>$sql = 'select id as &quot;Clave&quot;, firstname as &quot;Nombre&quot;, 
		  lastname as &quot;Apellido&quot;, created as &quot;Fecha Creacion&quot; <br>		from adoxyz';</pre>
<p>El codigo anterior lo puedes encontrar en los ejemplos incluidos con la distribucion en el
  archivo <i>adodb/tests/testpaging.php</i>, y la clase ADODB_Pager esta en
  <i>adodb/adodb-pager.inc.php</i>. 
  El codigo de ADODB_Pager puede ser modificado por el programador para que las ligas sean
  imagenes en lugar de textos, y el aburrido fondo blanco tenga colores mas interesantes.
<p>Tambien puedes habilitar que se muestre HTML modificando $pager->htmlSpecialChars = false. 
<p>Parte del codigo usado aqui fue proporcionado por Iv&aacute;n Oliva and Cornel G. </p>
<h3><a name="ex9"></a>Ejemplo 9: Exportando a formatos delimitados por tabulador o comas</h3>
<p>Se proporcionan funciones de ayuda para exportar en formatos delimitado por coma (CSV) y
   delimitado por tabuladores:</p>

<pre>
&lt;?php
<b>include_once('adodb/toexport.inc.php');</b>
include_once('adodb/adodb.inc.php');<br>
$db = &amp;NewADOConnection('mysql');
$db-&gt;Connect($server, $userid, $password, $database);

$rs = $db-&gt;Execute('select fname as &quot;Nombre&quot;, surname as &quot;Apellido&quot; from table');

print &quot;&lt;pre&gt;&quot;;
print <b>rs2csv</b>($rs); # obtenemos un texto en formao CSV
print '&lt;hr&gt;';

$rs-&gt;MoveFirst(); # Nota, en algunas bases de datos no funciona el MoveFirst

print <b>rs2tab</b>($rs,<i>false</i>); # obtenemos el texto delimitado por tabuladores
			 # false == omite el nombre de los campos en el primer renglon
print '&lt;hr&gt;';
$rs-&gt;MoveFirst();
<b>rs2tabout</b>($rs); # manda a la salida estandar (stdout) (tambien existe la funcion rs2csvout)
print &quot;&lt;/pre&gt;&quot;;

$rs-&gt;MoveFirst();
$fp = fopen($path, &quot;w&quot;);
if ($fp) {
   <b>rs2csvfile</b>($rs, $fp); # Escribe a un archivo (tambien existe la funcion rs2tabfile)
   fclose($fp);
}
?&gt;
</pre>
<p> Los regresos de carro y saltos de linea (CR/LF) se convierten a espacios. Los nombres de
  los campos se muestran en el primer renglon del texto. Las cadenas de caracteres que
  contengan el caracter de delimitador se encierran entre comillas dobles. Las comillas dobles
  se encierran tambien entre comillas. Esto cumple las guias de importacion y exportacion de
  MS Excel.
<p>Todas las funciones anteriores tienen un ultimo parametro opcional, $addtitles que tiene
  como valor por omision <i>true</i>. Cuando se le manda <i>false</i> se omite el nombre de los
  campos en la primera linea.<br>
<h3>Ejemplo 10: Filtros a la medida<a name="ex10"></a></h3>
<p>Algunas veces se desea pre procesar todos los renglones de un recordset antes de usarlos.
   Por ejemplo, deseamos convertir a mayusculas todo el texto de un recordset.
<pre>
&lt;?php
include_once('adodb/rsfilter.inc.php');
include_once('adodb/adodb.inc.php');

// Procesar con ucwords() cada elemento en un recordset
function do_ucwords(&$arr,$rs)
&#123;
	foreach($arr as $k => $v) &#123;
		$arr[$k] = ucwords($v);
	&#125;
&#125;

$db = NewADOConnection('mysql');
$db->PConnect('server','user','pwd','db');

$rs = $db->Execute('select ... from table');
$rs = <b>RSFilter</b>($rs,'do_ucwords');
</pre>
<p>La funcion <i>RSFilter</i> requiere dos parametros, el recordset y el nombre
  de la funcion del <i>filtro</i>. Regresa el recordset apuntando nuevamente al
  primer registro. La funcion <i>filter</i> requiere otros dos parametros, el renglon
  como un arreglo, y el objeto recordset. Para compatibilidad con futuras versiones se 
  recomienda no usar el objeto recordset original. </p>
<h3>Ejemplo 11:<a name="ex11"></a> Transacciones Inteligentes</h3>
El metodo anterior de manejo de transaciones requeria que hicieras esto
<pre>
$conn-><b>BeginTrans</b>();
$ok = $conn->Execute($sql);
if ($ok) $ok = $conn->Execute($sql2);
if (!$ok) $conn-><b>RollbackTrans</b>();
else $conn-><b>CommitTrans</b>();
</pre>
Esto es muy compliado para proyectos largos debido a que debes de ir siguiendole la huella
a los errores. Con transacciones inteligentes es mas sencillo. Se empieza una transaccion 
invocando StartTrans(): 
<pre>
$conn-><b>StartTrans</b>();
$conn->Execute($sql);
$conn->Execute($Sql2);
$conn-><b>CompleteTrans</b>();
</pre>
El metodo CompleteTrans() detecta cuando ocurrio un error SQL, y procesara Rollback o Commit 
segun sea necesario. Para forzar especificamente un evento rollback si no ha ocurrido un error,
usa el metodo FailTrans(). Toma en cuenta que el rollback se efectua HASTA el
CompleteTrans(), y no con el FailTrans().
<//--
El metodo CompleteTrans() detecta cuando ocurrio un error SQL, y procesara Rollback o Commit 
segun sea necesario. Para explicitamente provocar el rollback aun cuando no ha ocurrido un
error , usa el metodo FailTrans(). Toma en cuenta que el rollback se efectua HASTA el
CompleteTrans(), y no con el FaulTrans().
//-->
<pre>
$conn-><b>StartTrans</b>();
$conn->Execute($sql);
if (!CheckRecords()) $conn-><strong>FailTrans</strong>();
$conn->Execute($Sql2);
$conn-><b>CompleteTrans</b>();
</pre>
<p>Tambien se puede verificar si una transaccion a fallado usando HasFailedTrans(), el cual
  nos devuelve verdadero si se ha invocado FailTrans() o si hubo un error en la ejecucion
  de los SQL.
  Asegurese de usar HasFailedTrans() antes de llamar a CompleteTrans(), ya que esta
  unicamente funciona dentro de StartTrans y CompleteTrans.
<p>Finalmente, StartTrans/CompleteTrans son anidables, y unicamente el bloque exterior 
  se ejecuta. En contraste BeginTrans/CommitTrans/RollbackTrans NO son anidables. 
<pre>
$conn-><strong>StartTrans</strong>();
$conn->Execute($sql);
  $conn-><strong>StartTrans</strong>();    <font color="#006600"># ignorado</font>
  if (!CheckRecords()) $conn->FailTrans();
  $conn-><strong>CompleteTrans</strong>(); <font color="#006600"># ignorado</font>
$conn->Execute($Sql2);
$conn-><strong>CompleteTrans</strong>();
</pre>
<p>Nota: Actualmente no se manajean 'Savepoints'. 
<h2><a name="errorhandling"></a>Usando manejadores de errores a la medida y PEAR_Error</h2>
<p>ADOdb maeja las exception de PHP5.  Solamente incluye <i>adodb-exceptions.inc.php</i> y ya puedes atrapar
las excepciones conforme ocurran los errores.
</p><pre>
   <b>include("../adodb-exceptions.inc.php");</b> 
   include("../adodb.inc.php");     
   try { 
      $db = NewADOConnection("oci8://scott:bad-password@mytns/"); 
   } catch (exception $e) { 
      var_dump($e);
      adodb_backtrace($e-&gt;gettrace());
   } 
</pre>
<p> ADOdb proporciona dos estilos de manejo de errores que se pueden ajustar a nuestras 
  necesidades. El primero esta en el archivo <b>adodb-errorhandler.inc.php</b>. Este utiliza
  las funciones estandard de PHP <a href=http://php.net/error_reporting>error_reporting</a> 
  para controlar los tipos de mensajes de error a mostrar, y 
  <a href=http://php.net/trigger_error>trigger_error</a> que invoca al manejador de errores
  usual de PHP.
<p> Si se incluye el archivo anterior se provoca que se invoque a la funcion <i>trigger_error($errorstring,E_USER_ERROR)</i> cuando: <br>
  (a) Falla Connect() o PConnect(), o <br>
  (b) Una funcion que ejecuta un enunciado SQL como Execute() or SelectLimit() tiene un error.<br>
  (c) Parezca que GenID() esta en un ciclo sin fin. 
<p> La variable $errorstring generada por ADOdb contra informacion util de depuracion
  similar a los datos del error.log siguiente. El archivo adodb-errorhandler.inc.php 
  debe de ser incluido antes de crear cualquier objeto ADOConnection. 
<p> Si se define error_reporting(0), ningun error llegara al manejador de errores.
  Si se define error_reporting(E_ALL), todos los errores llegaran al manejador de errores.
  Ademas es ncesario usar <b>ini_set("display_errors", "0" or "1")</b> para controlar el
  despliegue de errores.
<pre>
&lt;?php
<b>error_reporting(E_ALL); # pasa cualquier mensaje de error al manajeador de errores
include('adodb/adodb-errorhandler.inc.php');</b>
include('adodb/adodb.inc.php');
include('adodb/tohtml.inc.php');
$c = NewADOConnection('mysql');
$c->PConnect('localhost','root','','northwind');
$rs=$c->Execute('select * from productsz'); # Table invalida productsz');
if ($rs) rs2html($rs);
?>
</pre>
<p> Si desea llevar una  bitacora de los mensajes de error, puede definir las siguientes 
  constantes opcionales ADODB_ERROR_LOG_TYPE y ADODB_ERROR_LOG_DEST. ADODB_ERROR_LOG_TYPE 
  es el tipo de mensaje (ver <a href=http://php.net/error_log>error_log</a> 
  en el manual de PHP). En este ejemplo lo asignamos a 3 que significa registar en el archivo
  definido por la constante ADODB_ERROR_LOG_DEST. 
<pre>
&lt;?php
<b>error_reporting(E_ALL); # reporta todos los errores
ini_set("display_errors", "0"); # pero no los muestra en la pantalla
define('ADODB_ERROR_LOG_TYPE',3);
define('ADODB_ERROR_LOG_DEST','C:/errors.log');
include('adodb/adodb-errorhandler.inc.php');</b>
include('adodb/adodb.inc.php');
include('adodb/tohtml.inc.php');

$c = NewADOConnection('mysql');
$c->PConnect('localhost','root','','northwind');
$rs=$c->Execute('select * from productsz'); ## Tabla invalida productsz
if ($rs) rs2html($rs);
?>
</pre>
El siguiente mensaje se registrara en el archivo error.log: 
<pre>
(2001-10-28 14:20:38) mysql error: [1146: Table 'northwind.productsz' doesn't exist] in
 EXECUTE("select * from productsz")
</pre>
<h3>PEAR_ERROR</h3>
El segundo manjeador de errores es <b>adodb-errorpear.inc.php</b>. Este crea una objeto
de la clase PEAR_Error cada vez que hay un error. El ultimo objeto PEAR_Error creado
puede ser obtenido usando la funcion ADODB_Pear_Error(). 
<pre>
&lt;?php
<b>include('adodb/adodb-errorpear.inc.php');</b>
include('adodb/adodb.inc.php');
include('adodb/tohtml.inc.php');
$c = NewADOConnection('mysql');
$c->PConnect('localhost','root','','northwind');
$rs=$c->Execute('select * from productsz'); #invalid table productsz');
if ($rs) rs2html($rs);
else &#123;
	<b>$e = ADODB_Pear_Error();
	echo '&lt;p>',$e->message,'&lt;/p>';</b>
&#125;
?>
</pre>
<p> Puedes usar una clase derivada de la clase PEAR_Error definiendo la constante 
  ADODB_PEAR_ERROR_CLASS antes de incluir adodb-errorpear.inc.php. Para facilitar la
  depuracion, se puede fijar el manejador por omision al principio el codigo PHP a
  PEAR_ERROR_DIE, lo cual provocara que se muestre el mensaje de error y que se detenga
  la ejecucion del codigo:
<pre>
include('PEAR.php');
PEAR::setErrorHandling('PEAR_ERROR_DIE');
</pre>
<p> Toma en cuenta que ADOdb no regresa un objeto PEAR_Error cuando ocurre un error.
  Se regresa falso. Hay que llamar a ADODB_Pear_Error() para obtener el ultimo error o
  usa la tecnica de PEAR_ERROR_DIE. 

<h3>MetaError y MetaErrMsg</h3>
 <p>SI tu necesitas mensajes que error que funcionen en varios manejadores de bases de datos, entonces usa 
   <a href="#metaerror">MetaError()</a>, que regresa un numero de error virtual basado en el sistema de numeracion de errores
de PEAR DB, y <a href=#metaerrmsg">MetaErrMsg()</a>.

<h4>Mensajes de Error</h4>
<p>Los mensajes de error son mostrados usando el metodo estatico ADOConnnection::outp($msg,$newline=true). 
  Normalmente se manda el mensaje al cliente (IE, Netscape, Mozilla, etc.). 
  Se puede modificar esto para efectuar un registro de errores.


<h2><a name="dsn"></a> Nombres de DSN</h2>
<p>ADOdb ahora tambien soporta conectarse usando DSN con el estilo de PEAR. Un nombre DSN es
   una cadena de texto con el siguiente formato:</p>
<p>$dsn = <i>&quot;$driver://$usuario:$contraseña@$servidor/$basededatos&quot;</i>;</p>
<p>Un ejemploe:</p>
<pre>   $username = 'root';<br>   $password = '';<br>   $hostname = 'localhost';<br>   $databasename = 'xphplens';<br>   $driver = 'mysql';<br>   $dsn = "$driver://$username:$password@$hostname/$databasename"<br>   $db = NewADOConnection(); <br>   # DB::Connect($dsn) also works if you include 'adodb/adodb-pear.inc.php' at the top<br>   $rs = $db-&gt;query('select firstname,lastname from adoxyz');<br>   $cnt = 0;<br>   while ($arr = $rs-&gt;fetchRow()) {<br>       print_r($arr); print "&lt;br&gt;";<br>   }</pre>
   <p></p>
<p>   <a href="#dsnsupport">Mas informacion y ejemplos de conexion</a> usando el formato DSN.

</p><h2><a name="pear"></a>Compatibilidad con PEAR</h2>
Soportamos DSNs (ver arriba), y las siguientes funciones:
 <pre><b> DB_Common</b>
    query - si regresa PEAR_Error si hay error
    limitQuery - si regresa PEAR_Error si hay error
    prepare - no regresa PEAR_Error si hay error
    execute - no regresa PEAR_Error si hay error
    setFetchMode - maneja ASSOC y ORDERED
    errorNative
    quote
    nextID
    disconnect
    
    getOne
    getAssoc
    getRow
    getCol
    
<b> DB_Result</b>
    numRows - regresa -1 si no esta soportado
    numCols
    fetchInto - no maneja indicar el fetchmode
    fetchRows - no maneja indicar el fetchmode
    free
</pre>

<h2><a name="caching"></a>Guardando recordsets en Memoria Intermedia (Caching)</h2>
<p>ADOdb maneja el caching de recordsets usando las funciones CacheExecute( ), 
  CachePageExecute( ) y CacheSelectLimit( ). Son similares a las funciones sin cache excepto
  que tienen un nuevo primer parametro, $secs2cache.
<p> Un ejemplo: 
<pre>
&lt;?php
<b>include</b>('adodb/adodb.inc.php'); # carga el codigo comun de ADOdb
$ADODB_CACHE_DIR = '/usr/ADODB_cache';
$<font color="#663300">conn</font> = &amp;ADONewConnection('mysql');  # crea la conexion
$<font color="#663300">conn</font>->PConnect('localhost','userid','','agora');# se conecta a agora
<font color="#000000">$<font color="#663300">sql</font> = 'select CustomerName, CustomerID from customers';
$<font color="#663300">rs</font> = $<font color="#663300">conn</font>->CacheExecute(15,$sql);</font></pre>
<p>El primer parametros es el numero de segundos a almacenar la busqueda.
  Las siguientes llamadas a esa misma busqueda usaran la version almacenda en memoria
  en el directorio $ADODB_CACHE_DIR. Para provocar que un busqueda se ejecute y se limpie del
  cache, hay que inviocar CacheExecute() con el primer parametro en cero.
  Tambien sirve invocar la funcion CacheFlush($sql).</p>
<p>Por seguridad se recomienda que tengas <i>register_globals=off</i> 
  en el archivo php.ini si usas $ADODB_CACHE_DIR.</p>
<p>A partir de la vsersion 1.80 de ADOdb, el parametro secs2cache es opcional en las
  funciones CacheSelectLimit() y CacheExecute(). Si se omiten, usaran el valor que tenga
  el parametro $connection->cacheSecs, por omision son 60 minutos. 
<pre>
	$conn->Connect(...);
	$conn->cacheSecs = 3600*24; # 24 horas de cache
	$rs = $conn->CacheExecute('select * from table');
</pre>
<p>Observe que magic_quotes_runtime debe de estar desactivado. 
<a href="http://phplens.com/lens/lensforum/msgs.php?LeNs#LensBM_forummsg">Mas informacion</a>, y no cambie 
$ADODB_FETCH_MODE (o SetFetchMode) ya que el recordset en memoria usara el valor de $ADODB_FETCH_MODE que tenia 
cuando el SQL fue ejecutada.


<h2><a name="pivot"></a>Tablas Pivote</h2>
<p>Desde la version 2.30, ADOdb maneja la generacion de SQL
para crear tablas pivote, tambien conocidas como tablas cruzadas. Para una mayor explicacion
lea este tutorial de DevShed <a href=http://www.devshed.com/Server_Side/MySQL/MySQLWiz/>Cross-Tabulation tutorial</a>. Suponemos que la base de datos maneja la expresion SQL case-when. </p> 
<p>En este ejemplo se usara la base de datos Northwind de MS Access. En la base de datos
  hay un tabla de productos, y deseamos analizar esta tabla <i>proveedores 
  versus categoria de productos</i>. Se mostraran los proveedores uno en cada renglon, y
  tabulado contra categoria. De esta manera en base a la tabla de la izquierda se generara
  la tabla pivote de la derecha:</p>
<table border="0" cellspacing="2" cellpadding="2" align="center">
  <tr>
	<td>
	  <table border="1" cellspacing="2" cellpadding="2" align="center" width="142">
		<tr> 
		  <td><i>Proveedor</i></td>
		  <td><i>Categoria</i></td>
		</tr>
		<tr> 
		  <td>proveedor1</td>
		  <td>categoria1</td>
		</tr>
		<tr> 
		  <td>proveedor2</td>
		  <td>categoria1</td>
		</tr>
		<tr> 
	 	  <td>proveedor2</td>
		  <td>categoria2</td>
		</tr>
	  </table>
	</td>
	<td> <font face="Courier New, Courier, mono">--&gt;</font></td>
	<td>
	  <table border="1" cellspacing="2" cellpadding="2" align="center">
		<tr> 
		  <td>&nbsp;</td>
		  <td><i>categoria1</i></td>
		  <td><i>categoria2</i></td>
		  <td><i>total</i></td>
		</tr>
		<tr> 
		  <td><i>proveedor1</i></td>
		  <td align="right">1</td>
		  <td align="right">0</td>
		  <td align="right">1</td>
		</tr>
		<tr> 
		  <td><i>proveedor2</i></td>
		  <td align="right">1</td>
		  <td align="right">1</td>
		  <td align="right">2</td>
		</tr>
	  </table>
	</td>
  </tr>
</table>
<p>El seiguiente codigo generara el SQL para la tabla pivote:
<pre>
# Consultar la tabla principal de "productos" 
# Poner los renglones al campo CompanyName
# y las columnas al valor de Categories
# definir las ligas para unir las tablas de busqueda
# "categories" y "suppliers"
#
 include &quot;adodb/pivottable.php&quot;;
 $sql = PivotTableSQL(
 	$conn,                                     # conexion adodb
 	'products p ,categories c ,suppliers s',   # tablas
	'CompanyName',                             # rows (multiple fields allowed)
	'CategoryName',                            # column to pivot on 
	'p.CategoryID = c.CategoryID and s.SupplierID= p.SupplierID' # joins/where
);
</pre>
<p> Esto generara el siguiente SQL:</p>
<p><code><font size="2">SELECT CompanyName, <br>
  SUM(CASE WHEN CategoryName='Beverages' THEN 1 ELSE 0 END) AS &quot;Beverages&quot;, 
  <br>
  SUM(CASE WHEN CategoryName='Condiments' THEN 1 ELSE 0 END) AS &quot;Condiments&quot;, 
  <br>
  SUM(CASE WHEN CategoryName='Confections' THEN 1 ELSE 0 END) AS &quot;Confections&quot;, 
  <br>
  SUM(CASE WHEN CategoryName='Dairy Products' THEN 1 ELSE 0 END) AS &quot;Dairy 
  Products&quot;, <br>
  SUM(CASE WHEN CategoryName='Grains/Cereals' THEN 1 ELSE 0 END) AS &quot;Grains/Cereals&quot;, 
  <br>
  SUM(CASE WHEN CategoryName='Meat/Poultry' THEN 1 ELSE 0 END) AS &quot;Meat/Poultry&quot;, 
  <br>
  SUM(CASE WHEN CategoryName='Produce' THEN 1 ELSE 0 END) AS &quot;Produce&quot;, 
  <br>
  SUM(CASE WHEN CategoryName='Seafood' THEN 1 ELSE 0 END) AS &quot;Seafood&quot;, 
  <br>
  SUM(1) as Total <br>
  FROM products p ,categories c ,suppliers s WHERE p.CategoryID = c.CategoryID 
  and s.SupplierID= p.SupplierID <br>
  GROUP BY CompanyName</font></code></p>
<p> Tambien se puede tomar como eje una <i>columna (campo) numerico</i> y <i>generar totales</i> 
	usando rangos. Este codigo se reviso en la version 2.41 de ADOdb y no es compatible 
    con versiones anteriores. El segundo ejemplo es:</p>
<pre>
 $sql = PivotTableSQL(
 	$conn,                                      # conexion adodb 
 	'products p ,categories c ,suppliers s',    # tablas
	'CompanyName',                              # renglones (se permiten, muiples campos)
   array(                                       # rango de columnas
	' 0 '      => 'UnitsInStock <= 0',
	"1 to 5"   => '0 < UnitsInStock and UnitsInStock <= 5',
	"6 to 10"  => '5 < UnitsInStock and UnitsInStock <= 10',
	"11 to 15" => '10 < UnitsInStock and UnitsInStock <= 15',
	"16+"      => '15 < UnitsInStock'
	),
	' p.CategoryID = c.CategoryID and s.SupplierID= p.SupplierID', # joins/where
	'UnitsInStock',                             # sum this field
	'Sum '                                      # sum label prefix
);
</pre> 
<p>Lo anterior generar este enunciado SQL: </p>
<p> <code> <font size="2">SELECT CompanyName, <br>
	SUM(CASE WHEN UnitsInStock &lt;= 0 THEN UnitsInStock ELSE 0 END) AS &quot;Sum 
	0 &quot;, <br>
	SUM(CASE WHEN 0 &lt; UnitsInStock and UnitsInStock &lt;= 5 THEN UnitsInStock 
	ELSE 0 END) AS &quot;Sum 1 to 5&quot;,<br>
	SUM(CASE WHEN 5 &lt; UnitsInStock and UnitsInStock &lt;= 10 THEN UnitsInStock 
	ELSE 0 END) AS &quot;Sum 6 to 10&quot;,<br>
	SUM(CASE WHEN 10 &lt; UnitsInStock and UnitsInStock &lt;= 15 THEN UnitsInStock 
	ELSE 0 END) AS &quot;Sum 11 to 15&quot;, <br>
	SUM(CASE WHEN 15 &lt; UnitsInStock THEN UnitsInStock ELSE 0 END) AS &quot;Sum 
	16+&quot;, <br>
	SUM(UnitsInStock) AS "Sum UnitsInStock", <br>
	SUM(1) as Total,<br>
	FROM products p ,categories c ,suppliers s WHERE p.CategoryID = c.CategoryID 
	and s.SupplierID= p.SupplierID <br>
	GROUP BY CompanyName</font></code><br>
	 </p>


<hr>

<h1>REFERENCIA de la Clase<a name="ref"></a></h1>
<p>Los parametros de funcion encerrados entre [ ] son opcionales.</p>
<h2>Variables Globales</h2>
<h3><a name="adodb_countrecs"></a>$ADODB_COUNTRECS</h3>
<p>Si el API de la base de datos no cuenta el numero de registros encontrados por el
    enunciado SELECT, la funcion RecordCount() es simulada cuando la variable global
	$ADODB_COUNTRECS tiene el valor true, que es el valor por omision.
	Esto se simula almacenando los registros, lo cual puede consumir mucha memoria para
    recordset muy grandes. Asignele el valor falso a esta variable para un mejor
    rendimiento. El valor de esta variable se verifica cada vez que se ejecuta una
    consulta, por lo cual se puede escoger cuales recordsets se desean contar.</p>
<h3><a name="adodb_cache_dir"></a>$ADODB_CACHE_DIR</h3>
<p>Si se utiliza la memoria intermedia (cache), esta variable contiene el directorio donde
  se almacenan los recordsets. Hay que definirla antes de invocar cualquier funcion de cache
  como CacheExecute( ). Por razones de seguridad se recomienda tener <i>register_globals=off</i>
  en el archivo php.ini si se usa el cache.</p>
<p>Con Unix y Apache, hay que modificar los permisos del directorio de cache a 
   algo similar a lo siguiente:</p>
<p>chown -R apache /ruta/al/cache<br>
  chgrp -R apache /ruta/al/cache </p>
<h3><a name="adodb_ansi_padding_off"></a>$ADODB_ANSI_PADDING_OFF</h3>
<p>Nos indica cuando hay que eliminar los espacios a la derecha de los campos CHAR (y tambien
   VARCHAR en el caso de ibase/firebird).
   Hay que asignarle true para que los elimine, el valor por omision es false.
   Por el momento funciona para los drivers de oci8po, ibase y firebird. Se agrego en la version
   4.01 de ADOdb.
<h3><a name="adodb_lang"></a>$ADODB_LANG</h3>
<p>Determina el lenguaje que usa la funcion MetaErrorMsg(). El valor por omision es 'en', que
  significa mensajes en ingles. Para ver que lenguajes estan disponibles, vea los archivos
  en adodb/lang/adodb-$leng.inc.php, donde $leng son los lenguajes disponibles.
<h3><a name="adodb_fetch_mode"></a>$ADODB_FETCH_MODE</h3>
<p>Determina como se obtienen los arreglos generados por los recordsets. 
  Los recordsets salvan este valor cuando se crean (ej. al Execute( ) o SelectLimit( 
  )), y cualquier cambio siguiente al valor de $ADODB_FETCH_MODE no tiene efecto en los
  recordsets existentes, unicamente en los recordsets creados posteriormente.</p>
<p>Se difinen la siguientes constantes:</p>
<p>define('ADODB_FETCH_DEFAULT',0);<br>
  define('ADODB_FETCH_NUM',1);<br>
  define('ADODB_FETCH_ASSOC',2);<br>
  define('ADODB_FETCH_BOTH',3); </p>
<p> Un ejemplo: 
<pre>
	$ADODB_<b>FETCH_MODE</b> = ADODB_FETCH_NUM;
	$rs1 = $db->Execute('select * from table');
	$ADODB_<b>FETCH_MODE</b> = ADODB_FETCH_ASSOC;
	$rs2 = $db->Execute('select * from table');
	print_r($rs1->fields); # muestra <i>array([0]=>'v0',[1] =>'v1')</i>
	print_r($rs2->fields); # muestra <i>array(['col1']=>'v0',['col2'] =>'v1')</i>
</pre>
<p> Como se observa en el ejemplo anterior, cada recordset almacena y usa un metodo diferente
    en base al valor que tenia $ADODB_FETCH_MODE cuando se creo el recordset al llamar el
    Execute().</p>
<p>Si no se le asigna valor, el valor por omision es ADODB_FETCH_DEFAULT. 
	El comportamiento en este modo es diferente en cada driver, por lo cual no confie en
	ADODB_FETCH_DEFAULT. Para portabilidad, se recomienda usar ADODB_FETCH_NUM 
	o ADODB_FETCH_ASSOC. Algunos drivers no manejan ADODB_FETCH_BOTH.</p>
<p><strong>Funcion SetFetchMode</strong></p>
<p>Algunos programadores prefieren usar una solucion mas orientada a objetos, donde el
   metodo de recuperacion se selecciona por medio de una funcion del objeto (metodo),
	<a href="#setfetchmode">SetFetchMode</a>. 
	Una vez que esta funcion se usa para un objeto de conexion,  este objeto ignorara
    la variable global $ADODB_FETCH_MODE y solo usara la propiedad interna fetchMode.</p>
<pre>
	$db->SetFetchMode(ADODB_FETCH_NUM);
	$rs1 = $db->Execute('select * from table');
	$db->SetFetchMode(ADODB_FETCH_ASSOC);
	$rs2 = $db->Execute('select * from table');
	print_r($rs1->fields); # muestra <i>array([0]=>'v0',[1] =>'v1')</i>
	print_r($rs2->fields); # muestra <i>array(['col1']=>'v0',['col2'] =>'v1')</i></pre>
<p>Para obtener el valor anterior del metodo de recuperacion, se puede usar la propiedad
    $db-&gt;fetchMode, o el valor regresado por SetFetchMode( ). 
<p><strong><a name="adodb_assoc_case"></a>ADODB_ASSOC_CASE</strong></p>
<p>Para algunos drivers se puede controlar si los nombres de los campos de los indices 
   de los arreglos asociativos esten en mayusculas o minusculas. 
   Para los drivers de sybase, oci8po, mssql, odbc e ibase y todos los otros drivers derivados
   de ellos, ADODB_ASSOC_CASE generara por omision recordset donde los nombres de los campos
   esten en minusculas. Hay tres posibles valores de la constante ADODB_ASSOC_CASE:</p>
<p> 0 = Nombres de campo en minusculas. $rs-&gt;fields['orderid']<br>
	1 = Nombres de campo en mayusculas. $rs-&gt;fields['ORDERID']<br>
	2 = Nombres de campo sin cambio. $rs-&gt;fields['OrderID'] -- Valor por
    omision desde ADOdb 2.90.</p>
<p>Para usarla hay que declarala antes de incluir adodb.inc.php.</p>
<p>define('ADODB_ASSOC_CASE', 2); # No cambiar las letras para ADODB_FETCH_ASSOC<br>
	include('adodb/adodb.inc.php'); </p>
<h3><font><a name="force_type"></a>$ADODB_FORCE_TYPE</font></h3>
<p><font>Ve el <a href="#ADODB_FORCE_TYPE">tutorial de GetUpdateSQL</a>.
</font></p>

<hr>
<h2>ADOConnection<a name="adoconnection"></a></h2>
<p>Objeto que realiza la conexion a la base de datos, ejecuta enunciados SQL y tiene un
    conjunto de funciones de utileria para estandirzar el formato de enunciados SQL
    para cosas coma la concatenacion y el formateo de fechas.</p>
<h3>Campos (propiedades) de ADOConnection</h3>
<p><b>databaseType</b>: Nombre del sistema de base de datos al cual nos conectamos. Ej. 
	<b>odbc</b> o <b>mssql</b> o <b>mysql</b>.</p>
<p><b>dataProvider</b>: El mecanismo subyacente usado para conectarse a la base de datos.
    Normalmente vale <b>native</b>, a menos que se use <b>odbc</b> o <b>ado</b>.</p>
<p><b>host: </b>Nombre del servidor o DSN a conectarse.</p>
<p><b>database</b>: Nombre de la base de datos a conectarse. Si se usa ado contiene el
    proveedor de datos (ado data provider).</p>
<p><b>user</b>: Nombre del usuario para conectarse a la base datos de datos. Por seguridad
     la contraseña no se almacena.</p>
<p><b>raiseErrorFn</b>: Permite definir una funcion para el manejo de errores. Para un ejemplo
    ve el archivo adodb-errorhandler.inc.php.</p>
<p><b>debug</b>: Con el valor <i>true</i> provoca que se muestren los mensajes de depuracion.</p>
<p><b>concat_operator</b>: Normalmente con valor '+' o '||'. Es el operador usado para
     concatenar cadenas en SQL. Lo usa la funcion <b><a href="#concat">Concat</a></b>.</p>
<p><b>fmtDate</b>: El formato usado por la funcion <b><a href="#dbdate">DBDate</a></b> 
	para enviar fechas a las base de datos. Ej. '#Y-m-d#' para Microsoft Access, 
	y ''Y-m-d'' para MySQL.</p>
<p><b>fmtTimeStamp: </b>El formato usado por la funcion <b><a href="#dbtimestamp">DBTimeStamp</a></b> 
	para enviar campos timestamp/datetime a la base de datos. </p>
<p><b>true</b>: El valor usado para representar 'verdadero' .Ej. '.T.' para Foxpro, '1' para 
	Microsoft SQL.</p>
<p><b>false: </b> El valor usado para representar 'falso'. Ej. '.F.' para Foxpro, '0' 
	para Microsoft SQL.</p>
<p><b>replaceQuote</b>: La cadena usada para protejer las comillas. Ej. dos comillas sencillas
    ('') para Microsoft SQL, y diagonal invertida-comilla (\") para MySQL. Usado por la funcion
    <a href="#qstr">qstr</a>.</p>
<p><b>autoCommit</b>: Indica si esta habilitado el 'commit' automatico. Por omision el
    valor es true.</p>
<p><b>charSet</b>: Indica el conjunto de caracteres por omision. Actualmente solo lo
    maneja interbase.</p>
<p><b>dialect</b>: Indica el dialecto por omision a usar. Actualmente solo lo maneja 
    interbase.</p>
<p><font><b>role</b>: Asigna el rol. Actualmente solo interbase/firebird lo manejan.</font></p>

<p><b>metaTablesSQL</b>: Enunciado SQL para obtener la lista de las tablas disponibles.
    Ej.  <i>SHOW TABLES</i> para MySQL.</p>
<p><b>genID</b>: El ultimo identificador generado por la funcion GenID(), si lo maneja la
     base de datos.</p>
<p><b>cacheSecs</b>: El numero de segundos para guardar en cache los recordsets si se omite
     el parametro #secs2cache en la funciones CacheExecute() o CacheSelectLimit(). 
     El valor por omision es 60 minutos.</p>
<p><b>sysDate</b>: Cadena que contiene el nombre de la funcion de la base de datos que
    genera la fecha fecha actual. Util en los INSERT y UPDATE.</p>
<p><b>sysTimeStamp</b>: Cadena que contiene el nombre de la funcion de la base de datos que
    genera el valor actual en formato current timestamp/datetime.</p>
<p><b>leftOuter</b>: Cadena que contiene el operador para hacer 'left outer join'. 
    Si no se conoce con valor false.</p>
<p><b>rightOuter</b>: Cadena que contiene el operador para hacer 'right outer join'.
    Si no se conoce con valor false.</p>
<p><b>ansiOuter</b>: Valor boleano que es verdadero si se permite hacer 'outer joins'  con la
    sintaxis ANSI. Ej. <i>select * from table1 left join table2 on p1=p2.</i></p>
<p><b>connectSID</b>: Valor boleano que indica si se debe considerar el parametro $database 
    en la conexion como SID para el driver oci8. Lo normal es falso. Utill para las version
    8.0.5 o anteriores de Oracle.</p>
<p><b>autoRollback</b>: Si tiene valor true las conexiones persistentes hacen un rollback
     automatico al momento del PConnect( ). El valor por omision es false.</p>
<hr>
<h3>Funciones/metodos principales de ADOConnection</h3>
<p><b>ADOConnection( )</b></p>
<p>Funcion constructor. No se invoque directamente. En su lugar usar ADONewConnection( ).</p>
<p><b>Connect<a name="connect"></a>($host,[$user],[$password],[$database])</b></p>
<p>Conexion no persistente al DSN o servidor $<b>host</b>, usando el usuario 
	$<b>user </b>y la contraseña $<b>password</b>. Si el servidor maneja varias bases de datos,
    se conecta a la base de datos $<b>database</b>. </p>
<p>Regresa true/false dependiendo de la conexion.</p>
<p>Nota para ADO: Si usas Microsoft ADO y no OLEDB, el parametro $database puede tener
	el 'OLEDB data provider' utilizado.</p>
<p>PostgreSQL: Otra manera de conectarse a la base de datos es mandando en el primer parametro
    $host la cadena de conexion estandard de PostgreSQL, y de esa forma se ignoran los
    demas parametros.</p>
<p>Para Oracle y Oci8, hay dos maneras de conectarse. La primera usando el nombre TNS 
	deinido en el archivo local tnsnames.ora (o ONAMES o HOSTNAMES). Colocar el nombre
    en el parametro $database, y poner el parametro $host a false. Como alternativa 
	poner el servidor en $host, y el SID en $database , esto se brinca el archivo tnsnames.ora. 
<p>Ejemplos: 
<pre> # $oraname en tnsnames.ora/ONAMES/HOSTNAMES
 $conn->Connect(false, 'scott', 'tiger', $oraname); 
 $conn->Connect('server:1521', 'scott', 'tiger', 'ServiceName'); # bypass tnsnames.ora</pre>
<p>Hay varios ejemplos de conexiones a bases de datos en <a href="#connect_ex">la parte de ejemplos</a>.</p>
<p><b>PConnect<a name="pconnect"></a>($host,[$user],[$password],[$database])</b></p>
<p>Para conexiones persistententes al DSN o servidor $<b>host</b>, usando el usuario 
    $<b>user</b> y contraseña $<b>password</b>. Si el servidor maneja multiples bases de
    datos, se conecta a la base de datos $<b>database</b>.</p>
<p>Ahora se realiza un rollback en las conexiones persistentes para algunas bases de datos
    desde la version 2.21, como se recomienda en el manual de PHP. Ver la bitacora de
    cambios o el codigo fuente para ver cuales bases de datos se afectaron.
<p>Regresa true/false dependiendo de la conexion. Para mas informacion vea Connect( ).</p>
<p>Desde ADOdb 2.21, se incluye el rollback automatico, ejemplo de uso:</p>
<pre> $conn = &amp;NewADOConnection('mysql');
 $conn-&gt;autoRollback = true; # el valor por omision es false
 $conn-&gt;PConnect(...); # aqui hace el rollback</pre>
<p> Con esto al hacer una conexion persistente con PConnect( ), ADOdb realizara primero un 
  rollback. Esto porque el documento que PHP no garantiza que se haga un rollback de las
  transacciones que fallen cuando se usan transacciones persistentes. Actualmente funciona 
  para Oracle, MySQL, PgSQL, MSSQL, ODBC. 
<p>Desde ADOdb 3.11 se puede forzar el uso de conexiones no persistentes aunque se invoque
   PConnect definiendo la constante ADODB_NEVER_PERSIST antes de invocar PConnect.
<p>Desde ADOdb 4.23, se regresa null si la extension no esta cargada.</p>
<p><b>NConnect<a name="nconnect"></a>($host,[$user],[$password],[$database])</b></p>
<p>Siempre genera una nueva conexion. En comparacion con PHP que algunas veces reutiliza
    las conexiones cuando se usa Connect() o PConnect(). Por lo pronto solo funciona con
    mysql (PHP 4.3.0 o posterior), postgresql y drivers derivado de oci8. 
    Para los otros drivers NConnect() funciona como Connect(). 
<p><b>IsConnected( )<a name="isconnected"></a></b></p>
<p>Regresa true si esta conectado a la base de datos. Se agrego en la version 4.53.

<p><b>Execute<a name="execute"></a>($sql,$inputarr=false)</b></p>
<p>Ejecuta el enunciado SQL en $<b>sql</b> y regresa un objeto de la clase ADORecordSet 
	si es correcto. Observe que si se ejectuta correctamente el SQL, siempre regresa
    un recordset, aun si se ejecuto un insert o un update.
	Tambien se puede mandar como parametro $sql un enunciado preparado con prepared 
    <a href=#prepare>Prepare()</a>.</p>
<p>Regresa un objeto derivado de la clase ADORecordSet. Ej. si esta conectado a mysql, 
   se obtiene un objeto de la clase ADORecordSet_mysql.
	Se regresa False si hubo un error en la ejecucion del sql.</p>
<p>El parametro $inputarr puede ser usado para ligar variables a parametros. A continuacion
    un ejemplo con Oracle:</p>
<pre>
 $conn->Execute("SELECT * FROM TABLE WHERE COND=:val", array('val'=> $val));
 </pre>
<p>Otro ejemplo usando ODBC, usa ?:</p>
<pre>
  $conn->Execute("SELECT * FROM TABLE WHERE COND=?", array($val));
</pre>
<a name="binding"></a>
<i>Ligando variables a parametros SQL (binding)</i><p>
El uso de variables en los enunciados SQL acelera la compilacion y el almacenamiento de los
enunciados SQL, resultando en un mayor desepeño.
Actualmente  Oracle, Interbase y ODBC manejan los SQL con variables.
El estilo de variables con ? de Interbase/ODBC se emula en las bases de datos que no manejan
los SQL con variables.
No hay que encerrar entre comillas las cadenas de cacrateres si se usa este metodo.
<p> El manejo de variables en SQL para los drivers odbc, interbase y oci8po es: 
<pre>
$rs = $db->Execute('select * from table where val=?', array('10'));
</pre>
Manejo de variables SQL para el driver oci8: 
<pre>
$rs = $db->Execute('select name from table where val=:key', array('key' => 10));
</pre>
<a name="bulkbind"></a>
<i>Liga de parametros en masa (Bulk binding)</i>
<p>Desde la version ADOdb 3.80, se maneja la liga de parametros en masa en el Execute(), 
   habiendo que pasar una arreglo bidimencional para que se ligue al enunciado
   INSERT, UPDATE o DELETE.
<pre>
$arr = array(
	array('Ahmad',32),
	array('Zulkifli', 24),
	array('Rosnah', 21)
	);
$ok = $db->Execute('insert into table (name,age) values (?,?)',$arr);
</pre>
<p>Esto proporciona un gran rendimiento ya que el enunciado SQL se prepara primero.
   El enunciado ya preparado se ejecuta sucesivamente para cada renglon del arreglo hasta que
   se procesan todos los renglones o hasta que ocurra un error.
   Es muy util para importar datos.

<p><b>CacheExecute<a name="cacheexecute"></a>([$secs2cache,]$sql,$inputarr=false)</b></p>
<p>Es similar al Execute, excepto que el recordset es almacenado en cache por $secs2cache 
    segundos en el directorio $ADODB_CACHE_DIR, y $inputarr solo recibe arreglos de una 
    dimension (no soporte 'bulk').
	Si se ejecuta CacheExecute() otra vez con los mismos parametros de $sql, $inputarr, 
	y tambien la misma base datos, usuario, y el recordset almacenado en cache no a 
	caducado, se regresa el recordset almacenado en el cache.
<pre>&lt;?php
  include('adodb/adodb.inc.php'); 
  include('adodb/tohtml.inc.php');
  $ADODB_<b>CACHE_DIR</b> = '/usr/local/ADOdbcache';
  $conn = &ADONewConnection('mysql'); 
  $conn->PConnect('localhost','userid','password','database');
  $rs = $conn-><b>CacheExecute</b>(15, 'select * from table'); # en cache por 15 secs
  rs2html($rs); /* muestra el recordset como tabla html */  
?>
</pre>
<p> Como alternativa, desde la version 1.80 de ADOdb, el parametro $secs2cache es opcional:</p>
<pre>	$conn-&gt;Connect(...);
   	$conn-&gt;cacheSecs = 3600*24; // en cache por 24 horas
	$rs = $conn-&gt;CacheExecute('select * from table');
</pre>
Si se omite el parametro $secs2cache, se usa el valor en $connection-&gt;cacheSecs 
(el valor por omision es de 3600 segundos, o 1 hora). 
Use CacheExecute() unicamente con enunciados SELECT. 
<p>Nota del desempe&ntilde;o: Haciendo varias medidas de desempe&ntilde;o (benchmarks) 
    encontre que varian tanto que es mejor hablar de cuando es de beneficio el uso del cache.
    Cuando el servidor de base de datos es <i>mas lento </i> que tu servidor Web o si la
    base de datos esta <i>muy sobrecargada </i> entonces el cache de ADOdb es bueno porque
    reduce la carga a tu servidor de base de datos.
	Si tu servidor de base de datos esta con poca carga o es mucho mas rapido que tu servidor
    Web, entonces el uso del cache podria de hecho reducir el desempe&ntilde;o.</p>
<p><b>ExecuteCursor<a name="executecursor"></a>($sql,$cursorName='rs',$parameters=false)</b></p>
<p>Ejecuta un procedimiento almacenado (SP) de Oracle, y regresa una variable de cursor 
     REF de Oracle como un recordset de ADOdb. No funciona con ninguna otra base de datos
     excepto oci8. 
	Gracias a Robert Tuttle por el dise&ntilde;o.
<pre>
    $db = ADONewConnection("oci8"); 
    $db->Connect("foo.com:1521", "uid", "pwd", "FOO"); 
    $rs = $db->ExecuteCursor("begin :cursorvar := getdata(:param1); end;", 
					'cursorvar',
					array('param1'=>10)); 
    # $rs es ahora como cualquier otro objeto recordset de ADOdb
    rs2html($rs);</pre>
<p>ExecuteCursor() es una funcion de ayuda que internamente hace esto:
<pre>
	$stmt = $db->Prepare("BEGIN :RS := SP_FOO(); END;", true); 
	$db->Parameter($stmt, $cur, 'RS', false, -1, OCI_B_CURSOR);
	$rs = $db->Execute($stmt);</pre>

<p>ExecuteCursor solo acepta un parametro de salida. Si tu SP tiene 2 parametros, usa: </p>
<pre>
  $vv = 'A%';
  $stmt = $db-&gt;PrepareSP("BEGIN list_tabs(:crsr,:tt); END;");
  $db-&gt;OutParameter($stmt, $cur, 'crsr', -1, OCI_B_CURSOR);
  $db-&gt;OutParameter($stmt, $vv, 'tt', 32); # return varchar(32)
  $arr = $db-&gt;GetArray($stmt);
  print_r($arr);
  echo " val = $vv"; ## outputs 'TEST'
</pre>
esto para el siguiente PL/SQL:
<pre>
  TYPE TabType IS REF CURSOR RETURN TAB%ROWTYPE;
  PROCEDURE list_tabs(tabcursor IN OUT TabType,tablenames IN OUT VARCHAR) IS
  BEGIN
       OPEN tabcursor FOR SELECT * FROM TAB WHERE tname LIKE tablenames;
       tablenames := 'TEST';
  END list_tabs;
</pre>

<p><b>SelectLimit<a name="selectlimit"></a>($sql,$numrows=-1,$offset=-1,$inputarr=false)</b></p>
<p>Si tiene exito regresa un recordset, en caso contrario regresa false. Ejectuta un enunciado
    select, simulando la clausula "LIMIT $numrows OFFSET $offset" del enunciado SELECT
    de PostgreSQL.</p>
<p>En PostgreSQL, SELECT * FROM TABLE LIMIT 3 da como resultado los primeros 3 registros 
	unicamente. Lo equivalente es <code>$connection->SelectLimit('SELECT * FROM TABLE',3)</code>. 
	Esta funcionalidad se simula para las bases de datos que no poseen esta caracteristica.</p>
<p> SELECT * FROM TABLE LIMIT 3 OFFSET 2 regresara los registros 3, 4 y 5 (es decir 
	despues del registro 2, regresa 2 registros). Lo equivalente en ADOdb es 
    <code>$connection->SelectLimit('SELECT * FROM TABLE',3,2)</code>.</p>
<p>Observa que es lo <i>contrario</i> de la clausula LIMIT de MySQL. Tambien se puede usar
	<code>$connection->SelectLimit('SELECT * FROM TABLE',-1,10)</code> para obtener los
    registros del 11 al ultimo.</p>
<p>El ultimo parametros $inputarr es para aquellas bases de datos que manejan la liga de
    variables a parametros como Oracle oci8. Esto reduce significativamente la demora
    por la compilacion de enunaciados SQL.  Aqui hay un ejemplo con Oracle :</p>
<pre>
 $conn->SelectLimit("SELECT * FROM TABLE WHERE COND=:val", 100,-1,array('val'=> $val));
 </pre>
<p>El driver oci8po (driver <b>po</b>rtable de Oracle) usa el metodo mas estandar de definir
   los parametros para las variables ?:
<pre>
 $conn->SelectLimit("SELECT * FROM TABLE WHERE COND=?", 100,-1,array($val));
</pre>
<p> 
<p>Ron Wilson informa que SelectLimit no funciona con UNIONs. 
<p><b>CacheSelectLimit<a name="cacheselectlimit"></a>([$secs2cache,] $sql, $numrows=-1,$offset=-1,$inputarr=false)</b></p>
<p>Similar a SelectLimit, excepto que el recordset obtenido se almacene en el cache por
   $secs2cache segundos en el directorio $ADODB_CACHE_DIR. </p>
<p>Desde la version 1.80, $secs2cache es opcional y se puede definir el tiempo de cache 
	en $connection-&gt;cacheSecs.</p>
<pre>	
   $conn-&gt;Connect(...);
   $conn-&gt;cacheSecs = 3600*24; // cache de24 horas
   $rs = $conn-&gt;CacheSelectLimit('select * from table',10);
</pre>
<p><b>CacheFlush<a name="cacheflush"></a>($sql=false,$inputarr=false)</b></p>
<p>Elimina (borra) cualquier recordsets en el cache $ADODB_CACHE_DIR del enunciado SQL en $sql. 
<p>Si no se manda ningun parametro, todos los archivos adodb_*.cache son eliminados.
<p> Si se desean borrar todos los archivos de cache en forma manual, hay que ejecutar el
  siguiente codigo PHP (funciona unicamente en Unix/linux): <br>
	<code> &nbsp; system(&quot;rm -f `find &quot;.$ADODB_CACHE_DIR.&quot; -name 
	adodb_*.cache`&quot;);</code></p>
<p>Para una limpieza general de los archivos caducos, se recomienda el uso de 
   <a href="http://www.superscripts.com/tutorial/crontab.html">crontab</a> 
	en Unix, o de <b>at.exe</b> en Windows, y un archivo de comandos similiar al
    siguiente:<br>
<font face="Courier New, Courier, mono"><br>
	#------------------------------------------------------ <br>
	# Este ejemplo en particular borra archivos en el <br>
    # directorio TMPPATH # con la cadena de caracteres &quot;.cache&quot; <br>
    # en el nombre que tengan mas de 7 dias.   <br>
	#------------------------------------------------------ <br>
	AGED=7 <br>
	find ${TMPPATH} -mtime +$AGED | grep &quot;\.cache&quot; | xargs rm -f <br>
	</font> </p>
<p><b>MetaError<a name="metaerror"></a>($errno=false)</b></p>
<p>Regresa un numero de error virtual, en base a la numeracion del DB de PEAR. Se puede
   necesitar incluir adodb-error.inc.php antes de invocar esta funcion. El parametro $errno
   es el numero de error nativo que se desea convertir. Si no se manda ningun parametro,
   MetaError invocara ErrorNo() para convertirlo. Si el numero de error no tiene equivalente
   virtual, MetaError regresara -1 (DB_ERROR).</p>
<p><b>MetaErrorMsg<a name="metaerrormsg"></a>($errno)</b></p>
<p>Recibe el numero de error generado por MetaError() para obtener el equivalente mensaje
    de error virtual.</p>
<p><b>ErrorMsg<a name="errormsg"></a>()</b></p>
<p>Regresa el ultimo mensaje de error. El mensaje de error se cambia despues de cada
   llamado a la funcion Execute(). 
<p>Puede regresar un texto aun si no ocurrio un error. No es necesario llamar esta funcion
   a menos que la funcion ADOdb regrese falso.</p>
<p>Nota: Si esta habiliado <b>debug</b>, los mensajes de error SQL se despliegan cada vez
    que la funcion <b>Execute</b> es llamada.</p>
<p><b>ErrorNo<a name="errorno"></a>()</b></p>
<p>Regresa el ultimo numero de error. Este numero de error se actualiza despues de
   cada invocacion de Execute().  Si se obtiene el valor 0, es que no hubo error.
<p> Tenga en cuenta que las versiones antiguas de PHP (antes de 4.0.6) no generan
    numero de error para conexiones ODBC. En lo general no es necesario invocar esta
    funcion a menos que la funcion ADOdb regrese el valor falso.</p>

<p><b>IgnoreErrors<a name="ignoreerrors"></a>($saveErrHandlers)</b></p>
<p>Te permite ignorar errores para que StartTrans()/CompleteTrans() no se vea afectado, asi como tampoco sea invocado
el menajador de erroes 'normal' en caso de ocurra un error.
Es util si qiueres verificar si existe un campo o una table sin que se invoque un error si no existe.
<p>Uso:
<pre>
$saveErrHandlers = $conn->IgnoreErrors();
$rs = $conn->Execute("select campo from alguna_table_que_pueda_no_existir");
$conn->IgnoreErrors($saveErrHandlers);
</pre>
<p>Advertencia: no invoques StartTrans()/CompleteTrans() dentro de un  bloque que usa IgnoreErrors().


<p><b>SetFetchMode<a name="setfetchmode"></a>($mode)</b></p>
<p>Asigna el modo para obtener los resultados para la conexion y lo almacena en
	$db-&gt;fetchMode. Los modos permitidos son ADODB_FETCH_ASSOC y ADODB_FETCH_NUM. 
	Para mas informacion vea <a href="#adodb_fetch_mode">$ADODB_FETCH_MODE</a>.</p>
<p>Regresa el metodo anterior, o falso si SetFetchMode( ) no habia sido llamado con
   anterioridad.</p>
<p><b>CreateSequence<a name="createseq"></a>($seqName = 'adodbseq',$startID=1)</b></p>
<p>Crea una secuencia. La siguiente vez que se invoque GenID( ), el valor que regrese
    sera $startID. Se agrego en la version 2.60. 
<p><b>DropSequenceD<a name="dropseq"></a>($seqName = 'adodbseq')</b></p>
<p>Borra una secuencia. Se agrego en la version 2.60. 
<p><b>GenID<a name="genid"></a>($seqName = 'adodbseq',$startID=1)</b></p>
<p>Genera un numero en secuencia. Funciona para interbase, mysql, postgresql, oci8, 
    oci8po, mssql, y los drivers basados en ODBC. Utiliza $seqName como el nombre de
    la secuencia. GenID() creara automaticamente la secuencia si no existe
    (con la condicion de que el usuario tenga permiso de crearla).
    Si no habra que crear la secuencia primero.
<p> Si el driver de su base de datos emula a las secuencias, el nombre de la tabla es el
    nombre de la secuencia. La tabla tiene una columna, 'id' la cual deberia de ser de
    tipo entero, o si se necesita algo mayor, numeric(16).
<p> Para ODBC y bases de datos que no manejan secuencias en forma nativa (ej mssql, mysql), 
	se crea la tabla para cada secuencia. Si la secuencia no habia sido definida anteriormente
    se creara con el valor inicial de $startID.</p>
<p>Nota, el driver de mssql anterior a la version 1.90 generaba GenID() de 16 bytes (GUID).
<p><b>UpdateBlob<a name="updateblob"></a>($table,$column,$val,$where)</b></p>
Permite almacenar el valor blob de $val en la columna $column de la tabla $table en el
renglon que cumpla el criterio $where. 
<p> Uso: 
<p> 
<pre>
	# para oracle
	$conn->Execute('INSERT INTO blobtable (id, blobcol) VALUES (1, empty_blob())');
	$conn->UpdateBlob('blobtable','blobcol',$blobvalue,'id=1');
	
	# las demas bases de datos (excepto oracle)
	$conn->Execute('INSERT INTO blobtable (id, blobcol) VALUES (1, null)');
	$conn->UpdateBlob('blobtable','blobcol',$blobvalue,'id=1');
</pre>
<p> Regresa verdadero si tiene existo, faslo en caso contrario. Sirve para MySQL, PostgreSQL, 
	Oci8, Oci8po e Interbase. Otros drivers pueden funcionar, dependiendo del estado
    de su desarrollo (informix ya funciona).
<p>Nota, cuando se lee un blob de Interbase blob con un SELECT, todavia necesita ser
	decodificado usando $connection->DecodeBlob($blob); para obtener el valor
    original en versiones de PHP anteriores a 4.1.0.
<p>Para PostgreSQL, se pueden almacenar blob en campos OID o bytea. 
	Se pueden usar campos bytea pero no OID con UpdateBlob( ). Y UpdateBlobFile( ) maneja 
    OID, pero no bytea.<br>
	<br>
	Si el parametro no es un OID, entonces UpdateBlob() asume que se esta almacenando
    en un campo bytea.
<p><b>UpdateClob<a name="updateclob"></a>($table,$column,$val,$where)</b></p>
Permite almacenar el valor clob en la variable $val en la columna $column de la
tabla $table en el renglon que cumpla el criterio $where. 
Es similar a UpdateBlob anterior, pero para 'Character Large OBjects'. 
<p> Uso:
<pre>
	# para oracle
	$conn->Execute('INSERT INTO clobtable (id, clobcol) VALUES (1, empty_clob())');
	$conn->UpdateBlob('clobtable','clobcol',$clobvalue,'id=1');
	
	# las demas bases de datos (excepto oracle)
	$conn->Execute('INSERT INTO clobtable (id, clobcol) VALUES (1, null)');
	$conn->UpdateBlob('clobtable','clobcol',$clobvalue,'id=1');
</pre>
<p><b>UpdateBlobFile<a name="updateblobfile"></a>($table,$column,$path,$where,$blobtype='BLOB')</b></p>
<p>Similar a UpdateBlob, excepto que se pasa como parametro el nombre del archivo
    que contiene el blob.
<p>Para PostgreSQL, si estas usando OID, use esta interfase. Esta interfase no
    maneja campos bytea.
<p>Regresa verdadero si tiene exito, falso en caso contrario.
<p><b>BlobEncode<a name="blobencode" id="blobencode"></a>($blob)</b> 
<p>Agunas bases de datos requieren que los blobs se codifiquen manualmente antes de ser
    almacenados. Nota, si se usa UpdateBlob( ) o UpdateBlobFile( ) la conversion es
    automatica y no hay necesidad de llamar esta funcion. Para PostgreSQL, BlobEncode() 
    puede unicamente ser usada en campos bytea.
<p>Regresa el valor del blob codificado.
<p>Nota, hay una propiedad del objeto conexion llamada <em>blobEncodeType</em> el cual
   tiene 3 valor legales:
<p>false - no hay necesidad de realizar codificacion ni decodificacion.<br>
	'I' - Se requiere la codificacion de blobs, y se obtiene un valor numerico (no hay
     necesidad de encerrar entre comillas).<br>
	'C' - Se requiere la codificacion de blobs, y se obtiene un valor alfanumerico (si
    requiere que se encierre entre comillas).
<p>Esto es solo para efectos de documentacion, para que el programa que maneja varios
    drivers de bases de datos sepa que es lo correcto cuando procesa blobs.
<p><strong>BlobDecode<a name="blobdecode"></a>($blob)</strong> 
<p>Algunas bases de datos requieren que los blobs sean decodificados manualmente despues
   de ejecutar el select. Si la base de datos no requiere la decodificacion, esta funcion
   regresara el blob sin cambio.
   Actualmente BlobDecode es requerido unicamente para una base de datos,
	PostgreSQL, y unicamente si se usan campos OID (si se usan campos bytea se
    decodifican automaticamente). El valor por omision maximo de un blob esta en $connection->maxblobsize, 
    que vale 256K en adodb 4.54.</p>
    <p>En ADOdb 4.54 y posterior el valor del blob es el parametro de salida.EN versiones anteriores el valor
    del blob se mandaba a stdout.
<pre>$rs = $db-&gt;Execute(&quot;select bloboid from postgres_table where id=$key&quot;);
$blob = $db-&gt;BlobDecode( reset($rs-&gt;fields) );</pre>
<p><b>Replace<a name="replace"></a>($table, $arrFields, $keyCols,$autoQuote=false)</b></p>
<p>Intenta hacer un UPDATE al registro, si no encuenta el registro, se genera y ejecuta
    un INSERT. Regresa 0 si falla, 1 si efectuo el update y 2 si no se encontro el
    registro y el insert fue con exito. Es diferente al replace de MySQL el cual
	borra el registro e inserta uno nuevo. Esto tambien significa que no se puede
    actualizar la llave primaria. La unica excepcion es con Interbase y sus derivados, 
    que si usan delete e insert debido a algunas limitantes del API de Interbase.
<p>Los parametros son el nombre de la tabla ($table), $arrFields que es un arreglo
    asociativo donde las llaves son los nombres de los campos y $keyCols es el nombre
    del campo llave primaria o un arreglo de nombres de campos si es una llave compuesta.
    Si $autoQuote tiene el valor true, entonces Replace() encerrara entre comillas todos
    los valor que no son numericos, los NULLs no se encomillan.
	Observe que este encomillado automatico no funcionara si se usan funciones SQL u
    operadores.
<p>Ejemplos: 
<pre>
# Llave primaria de un solo campo
$ret = $db->Replace('atable', 
	array('id'=>1000,'firstname'=>'Harun','lastname'=>'Al-Rashid'),
	'id',$autoquote = true);	
# genera UPDATE atable SET firstname='Harun',lastname='Al-Rashid' WHERE id=1000
# o INSERT INTO atable (id,firstname,lastname) VALUES (1000,'Harun','Al-Rashid')

# Llave compuesta
$ret = $db->Replace('atable2', 
	array('firstname'=>'Harun','lastname'=>'Al-Rashid', 'age' => 33, 'birthday' => 'null'),
	array('lastname','firstname'),
	$autoquote = true);

# sin el encomillado automatico
$ret = $db->Replace('atable2', 
	array('firstname'=>"'Harun'",'lastname'=>"'Al-Rashid'", 'age' => 'null'),
	array('lastname','firstname'));	
</pre>

<p><b>AutoExecute<a name="autoexecute"></a>($table, $arrFields, $mode, $where=false, $forceUpdate=true,$magicq=false)</b></p>
<p>Desde la version 4.56 de ADOdb, puedes genrerar y ejecutar automaticamente INSERTs y UPDATEs en la tabla indicada
con esta funcion, la cual encapsula a GetInsertSQL() y GetUpdateSQL().
<p>AutoExecute() inserta o actualiza la tabla $table dado un arreglo de campos ($arrFields), donde la llave es el 
nombre del campo y el valor del arreglo es el valor del campo a almacenar.
Toma en cuenta que hay un costo debido a que la tabla primero es consultada para obtener informacion de las llaves
antes de que se genere el SQL. Se genera un INSERT o un UPDATE en base al valor de $mode (ver en seguida).
<p>
Valores permitidos de $mode 
<ul>
    <li>'INSERT' o 1 o DB_AUTOQUERY_INSERT
    <li>'UPDATE' o 2 o DB_AUTOQUERY_UPDATE
</ul>
<p>Tu tienes que definir las constantes DB_AUTOQUERY_UPDATE y DB_AUTOQUERY_INSERT o incluir el archivo adodb-pear.inc.php.
<p>La clausula $where es obligatoria si $mode == 'UPDATE'. Si $forceUpdate=false entonces primero se consulta la base
de datos y verificamos si el valor del campo obtenido por la consulta coincide con el valor del arreglo; solo si
son diferentes se actualiza el campo.
<p>Regresa true si es correcto, false si hay error.
<p>Un ejemplo de esto es:
<pre>
$record["firstName"] = "Carol";
$record["lasTname"] = "Smith"; 
$conn->AutoExecute($table,$record,'INSERT');
# executes <i>"INSERT INTO $table (firstName,lasTname) values ('Carol',Smith')"</i>;

$record["firstName"] = "Carol";
$record["lasTname"] = "Jones"; 
$conn->AutoExecute($table,$record,'UPDATE', "lastname like 'Sm%'");
# executes <i>"UPDATE $table SET firstName='Carol',lasTname='Jones' WHERE lastname like 'Sm%'"</i>;
</pre>
<p>Nota: Una de las fortalezas del AutoExecute() de ADOdb es que solo los nombres de campo validos de la tabla $table son
actualizados. Si $arrFields contiene campos que no son de la tabla, son ignorados. Esto tiene un costo ya que
hay que consultar la base de datos para obtener el nombre de los campos, pero ya que tu no estas 
codificando el SQL, significa que tu probablemente no estas tan interesado en velocidad como en conveniencia.
<p>Desde 4.62, el nombre de la tabla puede ser forzado asignandolo en $rs->tableName antes de invocar
AutoExecute(), GetInsertSQL() o GetUpdateSQL().


<p><b>GetUpdateSQL<a name="getupdatesql"></a>(&$rs, $arrFields, $forceUpdate=false,$magicq=false)</b></p>
<p>Genera el enunciado SQL para actualizar una tabla, dandole el recordset $rs, y un
    arreglo con los campos modificados a comparar con el recordset ($arrFields, el cual 
    debe de ser un arreglo asociativo conteniendo el nombre de la columna y el nuevo valor).
	Si $forceUpdate vale true, entonces tambien se genera el SQL aun cuando $arrFields sea
    identico a $rs-&gt;fields. Requiere que el recordset sea asociativo. $magicq es utilizado
    para indicar si se desea encomillado automatico (ver <a href="#qstr">qstr()</a>). 
    El nombre de los campos en el arreglo puede ser con mayusculas o minusculas.
<p>Desde la version 4.52, se permite que pasas el parametro $force, y este tiene precedencia sobre la variable
global <a href="#ADODB_FORCE_TYPE">$ADODB_FORCE_TYPE</a>.
<p>Desde la version 4.62, el nombre de la tabla a usar puede ser modificada usando $rs->tableName antes de llamar a
 AutoExecute(), GetInsertSQL() o GetUpdateSQL().  </p>

<p><b>GetInsertSQL<a name="getinsertsql"></a>(&$rs, $arrFields,$magicq=false)</b></p>
<p>Genera el enunciado SQL para insertar en una tabla, dandole un recordset $rs. 
    Requiere que este en modo asociativo. $magicq se usa para indicar si se desea el
    encomillado automatico de los valores (ver <a href="#qstr">qstr()</a>). 
    El nombre de los campos en el arreglo puede ser con mayusculas o minusculas.
<p>Desde laversion 2.42, se puede pasar como parametro el nombre de la tabla en lugar del
  recordset (parametro $rs), y se generara automaticamente el enunciado de INSERT para
  esa tabla.</p>
<p>Desde la version 4.52, se permite que pasas el parametro $force, y este tiene precedencia sobre la variable
global <a href="#ADODB_FORCE_TYPE">$ADODB_FORCE_TYPE</a>.
<p>Desde la version 4.62, el nombre de la tabla a usar puede ser modificada usando $rs->tableName antes de llamar a
 AutoExecute(), GetInsertSQL() o GetUpdateSQL().  </p>

<p><b>PageExecute<a name="pageexecute"></a>($sql, $nrows, $page, $inputarr=false)</b> 
<p>Se usa para procesar un recordset por paginas. La pagina inicial es 1.
   Vea el <a href="#ex8">Ejemplo 8</a>.</p>
<p><b>CachePageExecute<a name="cachepageexecute"></a>($secs2cache, 
  $sql, $nrows, $page, $inputarr=false)</b> </p>
<p>Se usa para procesar un recordset por paginas. La pagina inicial es 1.
  Vea el <a href="#ex8">Ejemplo 8</a>. version con cache del PageExecute.</p>
<p></p>
<p><b>Close<a name="close"></a>( )</b></p>
<p>Cierra la conexion a la base de datos. PHP4 orgullosamente nos indica que ya no es
   necesario hacer la limpieza al final de la conexion por que el mecanismo de conteo
   de PHP4 lo hara por nosotros.</p>
<p><b>StartTrans<a name="starttrans"></a>( )</b></p>
<p>Inicia una transaccion monitoreada. Cada enunciado SQL que se ejectute, ADOdb lo 
   monitoreara buscando errores SQL, y si detecta alguno cuando se invoque
   CompleteTrans(), se hara un rollback automatico.
<p>
<p> Para entender porque StartTrans() es mejor que BeginTrans(), 
  examinemos algunas maneras de usar BeginTrans().
  A continuacion la manera <b>incorrecta</b> de usar las transacciones.
<pre>
$DB->BeginTrans();
$DB->Execute("update table1 set val=$val1 where id=$id");
$DB->Execute("update table2 set val=$val2 where id=$id");
$DB->CommitTrans();
</pre>
<p>debido a que no se verifica por errores. Es posible que se actualize la tabla
   table1 y que la actualizacion de la tabla table2 falle. Esta es una manera mejor (o 
   menos peor):
<pre>
$DB->BeginTrans();
$ok = $DB->Execute("update table1 set val=$val1 where id=$id");
if ($ok) $ok = $DB->Execute("update table2 set val=$val2 where id=$id");
if ($ok) $DB->CommitTrans();
else $DB->RollbackTrans();
</pre>
<p>Otra manera (con el metodo antiguo) de hacerlo desde la version de 2.0 de ADOdb: 
<pre>
$DB->BeginTrans();
$ok = $DB->Execute("update table1 set val=$val1 where id=$id");
if ($ok) $ok = $DB->Execute("update table2 set val=$val2 where id=$id");
$DB->CommitTrans($ok);
</pre>
<p> Es muy engorroso monitorear $ok por todo el codigo. StartTrans() es una mejora debido
   a que monitorea todos los erroers SQL por nosotros. Esto es particularmente util
   si invocas una funcion de 'caja negra' en el cual se pueden ejecutar varios enunciados
   SQL.  Adicionalmente,todas las llamadas a BeginTrans, CommitTrans o RollbackTrans dentro
   de un bloque StartTrans seran desabilitadas, por lo cual aunque la 'caja negra' haga un
   commit, sera ignorado.
<pre>
$DB->StartTrans();
CallBlackBox();   // Funcion que hace varias cosas
$DB->Execute("update table1 set val=$val1 where id=$id");
$DB->Execute("update table2 set val=$val2 where id=$id");
$DB->CompleteTrans($ok);
</pre>
  <p>Nota los bloques StartTrans son anidables, los bloques interiores son ignorados.
<p><b>CompleteTrans<a name="completetrans"></a>($autoComplete=true)</b></p>
  <p>Termina una transaccion iniciada con StartTrans(). Esta funcion monitorea por posibles
  errores SQL, y hara un 'commit' si no ocurrieron errores, en caso de algun error hara
  el 'rollback'. Regresa verdadero si efectuo el commit y false si llamo el roolback.
  Si el parametro $autoComplete es true se monitorean los errores y hace commit o rollback 
  segun sea el caso. Con $autoComplete en false se hace rollback aun cuando no se hayan
  detectado errores.
  <p><b>FailTrans<a name="failtrans"></a>( )</b></p>
  <p>Aborta una transaccion iniciada con StartTrans(). El rollback se hara hasta que se
     invoque CompleteTrans().
<p><b>HasFailedTrans<a name="hasfailedtrans"></a>( )</b></p>
	<p>Verifica si una transaccion inteligente ha fallado, es decir regresa true si ha
    habido un error SQL o si se invoco a FailTrans().
	Si no esta dentro de una transaccion inteligente regresa falso.
<p><b>BeginTrans<a name="begintrans"></a>( )</b></p>
<p>Inicia una transaccion. Desactiva el Commit automatico. Regresa true si se hace con exito.
  Algunas bases de datos siempre regresan false si no esta habilitado el manejo de 
  transacciones. Cualquier transaccion abierta hara rollback cuando se cierre la conexion.
  Algunas de las bases de datos que manejan transacciones son: Oracle, PostgreSQL, 
  Interbase, MSSQL, ciertas versiones de MySQL, DB2, Informix, Sybase, etc.</p>
 <p>Observe que  <a href=#starttrans>StartTrans()</a> y CompleteTrans() son un metodo
    superior para el manejo de transacciones, disponible desde ADOdb 3.40.
    Para una explicacion vea la documentacion de <a href=#starttrans>StartTrans()</a>.
<p>Tambien se puede usar el <a href=#errorhandling>manejador de errores</a> de ADOdb para
  matar y hacer rollback de la transaccion automaticamente. Algunas extensiones de
  bases de datos problematicas hacen 'commit' de todas las transacciones pendientes,
  por lo cual conviene por seguridad invocar manualmente $DB->RollbackTrans() en el 
  manejador de errores.
 <h4>Detectando Transacciones</h4>
 <p>Desde la version 2.50 de ADOdb, se puede detectar si se esta dentro de una transaccion.
   Hay que verificar si $connection->transCnt > 0. Esta variable se incrementa cada vez
   que se llama a BeginTrans(), y se decrementada cuando se invoca a RollbackTrans() o 
   CommitTrans().
<p><b>CommitTrans<a name="committrans"></a>($ok=true)</b></p>
<p>Termina una transaccion con exito. Regresa true si funciona. Si la base base de datos
  no maneja transaccion tambien regresara true ya que los datos son siempre almacenados.
<p>Si se manda el parametro $ok=false, invocara un 'rollback'. Vea el ejemplo de
  BeginTrans().</p>
<p><b>RollbackTrans<a name="rollbacktrans"></a>( )</b></p>
<p>Termina la transaccion regresando los cambios ('rollback'). Regresa true si tiene
   exito. Si la base de datos no maneja transacciones, regresara false ya que los datos
   no se pueden restaurar.
</p>

<p><b>SetTransactionMode<a name="SetTransactionMode"></a>($mode )</b></p>
<p>SetTransactionMode te permite indicar el modo de trasaccion a usar para todas las transacciones subsecuentes.
Nota: si tu tienes conexiones persistentes y usas mssql o mysql, puedes tener que regresar explicitamente el modo
de transaccion alprincipio de cada pagina.
Actualmente solo esta soportado para postgresql, mssql, mysql con InnoDB y oci8. Por ejemplo:
<pre>
$db->SetTransactionMode("SERIALIZABLE");
$db->BeginTrans();
$db->Execute(...); $db->Execute(...);
$db->CommiTrans();

$db->SetTransactionMode(""); // lo regreso al valor por omision
$db->StartTrans();
$db->Execute(...); $db->Execute(...);
$db->CompleteTrans();
</pre>

<p>Valores permitidos son:
<ul>
<li>READ UNCOMMITTED (permite 'dirty reads', pero es mas rapido)
<li>READ COMMITTED (valor por omision para postgres, mssql y oci8)
<li>REPEATABLE READ (omision para mysql)
<li>SERIALIZABLE (mas lento y mas restrictivo)
</ul>
<p>Puedes tambiar indicar un valor especifico para tu base de datos como  'SNAPSHOT' para mssql o 'READ ONLY' para
 oci8/postgres.
<p>Ve la secccion 'transaction levels' para <a href=http://www.postgresql.org/docs/8.1/interactive/sql-set-transaction.html>PostgreSQL</a>,
<a href=http://www.stanford.edu/dept/itss/docs/oracle/10g/server.101/b10759/statements_10005.htm>Oracle</a>,
<a href=http://dev.mysql.com/doc/refman/5.0/en/set-transaction.html>MySQL</a>, 
<a href=http://msdn2.microsoft.com/en-US/ms173763.aspx>MS SQL Server</a> e
<a href="http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.sqlt.doc/sqltmst239.htm">Informix</a>.


<p><b>GetAssoc<a name=getassoc1></a>($sql,$inputarr=false,$force_array=false,$first2cols=false)</b></p>
<p>Regresa un arreglo asociativo para el enunciado SQL solicitado en $sql, opcionalmente
   puede tener liga de parametros usando $inputarr. Si el numero de columnas obtenido es
   mayor a dos, se genera un arreglo bidimensional con la primera columa del recordset como
   la llave del resto de los campos. Si hay exactamente dos columnas, se obtiene un arreglo
   de una dimension donde la llave (primera columna) apunta a su valor (segunda columna).
   A menos que $force_array tenga el valor true, en cuyo caso se crea un arreglo para
   cada valor.
<p> Ejemplos:<a name=getassocex></a></p>
<p>Si tenemos los siguientes datos en el recordset:</p>
<p>renglon1: Manzana, Fruta, Comible<br>
  renglon2: Cactus, Planta, Incomible<br>
  renglon3: Rosa, Flor, Comible</p>
<p>GetAssoc generara el siguiente arreglo asociativo bidimensional:</p>
<p>Manzana =&gt; array[Fruta, Comible]<br>
  Cactus =&gt; array[Planta, Incomible]<br>
  Rosa =&gt; array[Flor,Comible]</p>
<p>Si el conjunto de datos es:</p>
<p>renglon1: Manzana, Fruta<br>
  renglon2: Cactus, Planta<br>
  renglon3: Rosa, Flor</p>
<p>GetAssoc generara el siguiente arreglo asociativo (con $force_array==false):</p>
<p>Manzana =&gt; Fruta<br>
  Cactus=&gt;Planta<br>
  Rosa=&gt;Flor</p>
<p>La funcion regresa el arreglo asociativo, o falso si ocurrio un error.</p>
<p><b>CacheGetAssoc<a name="cachegetassoc"></a>([$secs2cache,] $sql,$inputarr=false,$force_array=false,$first2cols=false)</b></p>
<p>La version con cache de la funcion <a href=#getassoc1>GetAssoc</a> anterior.
<p><b>GetOne<a name="getone"></a>($sql,$inputarr=false)</b></p>
<p>Ejecuta el enunciado SQL y regresa el primer campo del primer renglon. El recordset 
  y el resto de los renglones son descartados automaticamente. Si hay un error la funcion
  regresa false.
<p><b>GetRow<a name="getrow"></a>($sql,$inputarr=false)</b></p>
<p>Ejecuta el enunciado SQL y regresa el primer renglon como un arreglo. El recordset y el
  resto de los renglones son descartados automaticamente. Si hay un error la funcion
  regresa false.
<p><b>GetAll<a name="getall"></a>($sql)</b></p>
<p>Ejecuta el enunciado SQL y regresa todos los renglones como un arreglo bidimensional.
   El recordset es descartado automaticamente. Si hay un error la funcion regresa false.
 <p><b>GetCol<a name="getcol"></a>($sql,$inputarr=false,$trim=false)</b></p>
<p>Ejecuta el enunciado SQL y regresa todos los elementos de la primera columna
   como un arreglo dimencional. El recordset es descartado automaticamente. Si ocurre un error
   regresa false.</p>
<p><b>CacheGetOne<a name="cachegetone"></a>([$secs2cache,] 
  $sql,$inputarr=false), CacheGetRow<a name="cachegetrow"></a>([$secs2cache,] $sql,$inputarr=false), CacheGetAll<a name="cachegetall"></a>([$secs2cache,] 
  $sql,$inputarr=false), CacheGetCol<a name="cachegetcol"></a>([$secs2cache,] 
  $sql,$inputarr=false,$trim=false)</b></p>
<p>Similares a las funciones Get* anteriores, excepto que el recordset es almacenado en el
  cache indicado en $ADODB_CACHE_DIR por $secs2cache segundos. Es bueno para acelerar
  preguntas en datos que cambian poco. El parametro $secs2cache es opcional. Si se omite 
  se usa el valor de $connection-&gt;cacheSecs (normalmente de 3600 segundos o 1 hora).
<p><b>Prepare<a name="prepare"></a>($sql )</b></p>
<p>Prepara (compila) un enunciado SQL para ejecutarse repetitivamente. Los parametros se
   representan por ?, excepto para el driver oci8, que emplea el metodo usual de Oracle de
   :varname.</p>
<p>Regresa un arreglo que contiene el enunciado SQL original como primera posicion, las
   demas posiciones del arreglo varian para cada driver.
  Si hubo un error o se esta emulando el Prepare( ), se regresa la cadena $sql original.
  Esto es porque todo el manejo de errores se hace en el Execute().</p>
<p>Prepare( ) no puede ser usado en funciones que usan la tecnica de modificar el 
   enunciado SQL como PageExecute( ) y SelectLimit( ).</p>
<p>Ejemplo:</p>
<pre>
$stmt = $conn-&gt;Prepare('insert into table (col1,col2) values (?,?)');
for ($i=0; $i &lt; $max; $i++)
    $conn-&gt;Execute($stmt,array((string) rand(), $i));
</pre>
<p>Tambien revisa InParameter(), OutParameter() y PrepareSP(). Solo esta
   soportado internamente por interbase, oci8 y algunos drivers basados en ODBC, en los
   demas casos es emulado. No hay ninguna ganancia en el rendimiendo usando
   Prepare() emulados. 
<p> Importante: Debido a las limitaciones o fallas en el PHP, si tienes errores al ejecutar
  SQLs preparados, pon $ADODB_COUNTRECS = false antes de prepararlos. Esto ha sido
  observado con ODBC. 
<p><b>IfNull<a name="ifnull"></a>($field, $nullReplacementValue)</b></p>
<p>Funcion IFNULL compatible (NVL para Oracle). Regresa una cadena de caracteres que
   representa la funcion que verifica si $field es nulo (NULL), y si lo es, 
   le cambia el valor regresado por $nullReplacementValue. Ej.</p>
<pre>$sql = <font color="#993300">'SELECT '</font>.$db-&gt;IfNull('name', <font color="#993300">&quot;'- unknown -'&quot;</font>).<font color="#993300"> ' FROM table'</font>;</pre>

<p><b>length<a name="length"></a></b></p>
<p>No es una funcion sino una propiedad. Algunas bases de datos tiene la funcion 
   "length" y otras "len" para medir la longitud de una cadena. Para usar la propiedad:
<pre>
  $sql = <font color="#993300">"SELECT "</font>.$db->length.<font color="#993300">"(field) from table"</font>;
  $rs = $db->Execute($sql);
</pre>
<p><b>random<a name="random"></a></b></p>
<p>Tampoco es una funcion sino una propiedad. Contiene la cadena que representa a la
   funcion sql que genera un numero aleatorio entre 0.0 y 1.0 inclusive.
<p><b>substr<a name="substr"></a></b></p>
<p>Tambien es una propiedad. Algunas bases de datos tienen la funcion "substr" y otras
   la funcion "substring" para recuperar parte de una cadena. Ejemplo de uso:
<pre>
  $sql = <font color="#993300">"SELECT "</font>.$db->substr.<font color="#993300">"(field, $offset, $length) from table"</font>;
  $rs = $db->Execute($sql);
</pre>
<p>Para todas las bases de datos, el primer parametro de <i>substr</i> es el campo, el
   segundo es el desplazamiento (1 es el principio) para empezar la sub-cadena, 
   y el tercero es el largo.
<p><b>Param<a name="param"></a>($name)</b></p>
<p>Genera el caracter para marcar la posicion de los parametros.  En la mayoria de las
   bases de datos el caracter es "?". Sin embargo algunas bases de datos usan marcadores 
   con nombre, Oracle por ejemplo usa ":somevar". Estos nos permite definir enunciados SQL
   con parametros que sean compatibles.
<pre><font color="#000000">$sql = <font color="#993300">'insert into table (col1,col2) values ('</font>.$conn-&gt;Param('a').<font color="#993300">','</font>.$conn-&gt;Param('b').<font color="#993300">')'</font>;
<font color="#006600"># genera 'insert into table (col1,col2) values (?,?)'
# o      'insert into table (col1,col2) values (:a,:b)</font>'
$stmt = $conn-&gt;Prepare($sql);
$stmt = $conn-&gt;Execute($stmt,array('one','two'));
</font></pre>
<font color="#000000"> 
<p></p>
<p><b>PrepareSP</b><b><a name="preparesp"></a></b><b>($sql, $cursor=false )</b></p>
<p>Al llamar procedimientos almaceneados (SP) de mssql y oci8 (oracle), PrepareSP() nos
   permite ligar directamente a un parametro que regresa un valor, o el manejo especial
   de LOBs.
<p>Regresa el mismo arreglo o cadena $sql como el Prepare( ). Si <b>NO</b> se necesita
   ligar a un valor de salido, se deberia de usar Prepare().
<p>El segundo parametro, $cursor solo se usa con oci8. Con valor true provoca que
   se llame a OCINewCursor; esto para el manejo de REF CURSOR.
<p>Para ejemplos del uso de PrepareSP( ), vea InParameter( ) a continuacion. 
<p>Nota: en el driver de mssql, preparar procedimientos almacenados requiere que se llame
   a una funcion especial, mssql_init( ), la cual es invocada por esta funcion.
   PrepareSP( ) esta disponible en todos los drivers y es emulado invocando a Prepare( ). </p>
<p><b> InParameter<a name="inparameter"></a>($stmt, $var, $name,
  $maxLen = 4000, $type = false )</b></p>
Liga una variable PHP como entrada a una variable del procedimiento almacenado.
  El parametro <i>$stmt</i> es el valor que regreso PrepareSP(), <i>$var</i> es la variable
  PHP a ligar, $name es el nombre de la variable del procedimiento almacenado.
  <i>$maxLen</i> es opcional y es la longitud maxima de los datos a ligar y
  $type depende de cada base de datos.
 Consulte la documentacion de
 <a href=http://php.net/mssql_bind>mssql_bind</a> y 
 <a href=http://php.net/ocibindbyname>ocibindbyname</a> en php.net para mas 
  informacin de los valores autorizados de $type. 
 <p>InParameter() es una funcion envolvente que llama Parameter() con $isOutput=false. 
   La ventaja de esta funcion es que es auto descriptiva, debido a que ya no es 
   necesario el parametro $isOutput.  Actualmente solo para mssql y oci8.
  <p>Un ejemplo usando oci8:
  <pre><font color="green"># Para Oracle, Prepare y PrepareSP son identicos</font>
$stmt = $db-&gt;PrepareSP(
	<font color="#993300">&quot;declare RETVAL integer; 
	begin
	:RETVAL := </font><font color="#993300">SP_RUNSOMETHING</font><font color="#993300">(:myid,:group);
	end;&quot;</font>);
$db-&gt;InParameter($stmt,$id,'myid');
$db-&gt;InParameter($stmt,$group,'group',64);
$db-&gt;OutParameter($stmt,$ret,'RETVAL');<br>$db-&gt;Execute($stmt);
</pre>
<p> Este mismo ejemplo usando mssql:</p>
</font> 
<pre><font color="#000000"><font color="green"># @RETVAL = SP_RUNSOMETHING @myid,@group</font>
$stmt = $db-&gt;PrepareSP(<font color="#993333">'<font color="#993300">SP_RUNSOMETHING</font>'</font>); 
<font color="green"># ¡Observa que el nombre de parametro no tiene @ al principio!</font>
$db-&gt;InParameter($stmt,$id,'myid');
$db-&gt;InParameter($stmt,$group,'group',64);
<font color="green"># El valor de salida en mssql, RETVAL, es un nombre fijo</font> 
$db-&gt;OutParameter($stmt,$ret,'RETVAL');
$db-&gt;Execute($stmt); </font></pre>
<p>Tome en cuenta que la unica diferencia entre la implementacion de oci8 y mssql es $sql.</p>
<p> En mssql si el parametro $type tiene valor false, $type se determinara dinamicamente
  en base al tipo de variable PHP proporcionada. <font face="Courier New, Courier, mono">
  (string =&gt; SQLCHAR, boolean =&gt;SQLINT1, integer =&gt;SQLINT4 o 
  float/double=&gt;SQLFLT8)</font>.
<p> Para oci8, $type puede ser OCI_B_FILE (Binary-File), OCI_B_CFILE (Character-File), 
OCI_B_CLOB (Character-LOB), OCI_B_BLOB (Binary-LOB) y OCI_B_ROWID (ROWID). Para pasar
NULL hay que usar <font face="Courier New, Courier, mono"> $db-&gt;Parameter($stmt, 
$null=null, 'param')</font>. 
  <p><b> OutParameter<a name="outparameter"></a>($stmt, $var, $name, 
  $maxLen = 4000, $type = false )</b></p>
  Liga una variable PHP con la salida de una variable de un procedimiento almacenado.
  El parametro <i>$stmt</i> es el valor que regreso PrepareSP(), <i>$var</i> es la
  variable PHP que se se desea ligar, <i>$name</i> es el nombre de la variable del 
  procedimiento almacenado. Opcionalmente, <i>$maxLen</i> es la longitud maxima de datos
  a ligar, y <i>$type</i> que depende de cada base de datos.
  <p>OutParameter() es una funcion envolvente que llamada Parameter() con $isOutput=true. 
  La ventaja de esta funcion es que es auto descriptiva, debido a que ya no es necesario
  el parametro $isOutput. Actualmente solo para mssql y oci8.
<p> Para un ejemplo vea <a href=#inparameter>InParameter</a>.

<p><b> Parameter<a name="parameter"></a>($stmt, $var, $name, $isOutput=false, 
  $maxLen = 4000, $type = false )</b></p>
<p>Observacion: Esta funcion esta <b>descontinuada</b>, debido a las nuevas funciones 
   <i>InParameter()</i> y <i>OutParameter()</i>. Estas son mejores porque son
   auto descriptivas.
<p>Agrega un parametro adecuado para regresar valores o el manejo especial de 
  datos (ej, LOBs) despues de que el enunciado ha sido preparado con PrepareSP().
  Actualmente solo para mssql y oci8. Los parametros son:<br>
  <br>
  $<i><b>stmt</b></i> Enunciado regresado por Prepare() o PrepareSP().<br>
  $<i><b>var</b></i> Variable PHP a ligar. ¡Asegurarse de inicializarla!<br>
  $<i><b>name</b></i> Nombre de la variable del procedimiento almacenado a ligarse.<br>
  [$<i><b>isOutput</b></i>] Indica el sentido del parametro, 0/false=Entrada 1=Salida 
  2= Entrada/Salida. Se ignora en el driver oci8 ya que este auto detecta el sentido.<br>
  [$<b>maxLen</b>] Longitud maxima de la variable.<br>
  [$<b>type</b>] Consulta <a href="http://php.net/mssql_bind">mssql_bind</a> y 
  <a href="http://php.net/ocibindbyname">ocibindbyname</a> en php.net para 
  mas informacion de los valores legales de $type.</p>
<p>Por ultimo, para oci8, los parametros pueden ser reusados sin llamar nuevamente a
   PrepareSP( ) o Parameters. Esto no es posible con mssql. Un ejemplo con oci8:</p>
<pre>$id = 0; $i = 0;
$stmt = $db-&gt;PrepareSP( <font color="#993300">&quot;update table set val=:i where id=:id&quot;</font>);
$db-&gt;Parameter($stmt,$id,'id');
$db-&gt;Parameter($stmt,$i, 'i');
for ($cnt=0; $cnt &lt; 1000; $cnt++) {
	$id = $cnt; <br>	$i = $cnt * $cnt; <font color="green"># ¡Funciona para oci8!</font>
	$db-&gt;Execute($stmt); <br>}</pre>
<p><b>Bind<a name="bind"></a>($stmt, $var, $size=4001, $type=false, $name=false)</b></p>
<p>Esta es una funcion de bajo nivel manejada unicamente por el driver de oci8. 
   <b>Evite usarla</b> a menos que unicamente desea dar soporte a Oracle. La funcion
   Parameter( ) es el metodo recomendado para ligar variables.
<p>Bind( ) nos permite ligar variables en el enunciado sql. Liga la variable PHP a un
  nombre definido en el enunciado SQL de Oracle que fue previamente preparado usando
  Prepare(). Las variables nombradas de Oracle empiezan con dos puntos (:), y 
  ADOdb necesita que las variables se llamen :0, :1, :2, :3, etc. 
  La primera vez que se invoque Bind() tomara :0, la segunda invocacion tomara 
  :1, etc. El uso de Bind() puede proporcionaar un 100% de incremento de velocidad para
  enunciados insert, select y update. 
<p>Los otros parametros, $size asigna el tamaño de memoria para almacenamiento de datos,
   $type puede tener los valores OCI_B_FILE (Binary-File), OCI_B_CFILE (Character-File), 
  OCI_B_CLOB (Character-LOB), OCI_B_BLOB (Binary-LOB) y OCI_B_ROWID (ROWID). 
  Por ultimo, en lugar de usar los nombres :0, :1, etc., se pueden definir los nombres 
  a ligar usando $name. 
<p>El siguiente ejemplo usa tres variables a ligar: p1, p2 y p3. Estas variables se 
   ligan a :0, :1 y :2.
<pre>$stmt = $DB-&gt;Prepare(&quot;insert into table (col0, col1, col2) values (:0, :1, :2)&quot;);
$DB-&gt;Bind($stmt, $p1);
$DB-&gt;Bind($stmt, $p2);
$DB-&gt;Bind($stmt, $p3);
for ($i = 0; $i &lt; $max; $i++) { 
   $p1 = ?; $p2 = ?; $p3 = ?;
   $DB-&gt;Execute($stmt);
}</pre>
<p>Tambien se puede usar variables con nombre:</p>
<pre>
$stmt = $DB-&gt;Prepare(&quot;insert into table (col0, col1, col2) values (:nombre0, :nombre1, :nombre2)&quot;);
$DB-&gt;Bind($stmt, $p1, &quot;nombre0&quot;);
$DB-&gt;Bind($stmt, $p2, &quot;nombre1&quot;);
$DB-&gt;Bind($stmt, $p3, &quot;nombre2&quot;);
for ($i = 0; $i &lt; $max; $i++) { 
   $p1 = ?; $p2 = ?; $p3 = ?;
   $DB-&gt;Execute($stmt);
}</pre>
<p><b>LogSQL($enable=true)<a name=logsql></a></b></p>
Llama este metodo para instalar el sistema de registro y medicion de 
enunciados SQL (usando fnExecute). Todos los enunciados SQL seran registrados en
la tabla adodb_logsql de la base de datos. Si la tabla no existe, ADOdb la creara
si tienes los premisos necesarios. Regresa el estado previo de registro (true para
habilitado, false para desabilitado). Este un ejemplo del DDL para algunas bases
de datos:
<p> 
<pre>
		<b>mysql:</b>
		CREATE TABLE adodb_logsql (
		  created datetime NOT NULL,
		  sql0 varchar(250) NOT NULL,
		  sql1 text NOT NULL,
		  params text NOT NULL,
		  tracer text NOT NULL,
		  timer decimal(16,6) NOT NULL
		)
		
		<b>postgres:</b>
		CREATE TABLE adodb_logsql (
		  created timestamp NOT NULL,
		  sql0 varchar(250) NOT NULL,
		  sql1 text NOT NULL,
		  params text NOT NULL,
		  tracer text NOT NULL,
		  timer decimal(16,6) NOT NULL
		)
		
		<b>mssql:</b>
		CREATE TABLE adodb_logsql (
		  created datetime NOT NULL,
		  sql0 varchar(250) NOT NULL,
		  sql1 varchar(4000) NOT NULL,
		  params varchar(3000) NOT NULL,
		  tracer varchar(500) NOT NULL,
		  timer decimal(16,6) NOT NULL
		)
		
		<b>oci8:</b>
		CREATE TABLE adodb_logsql (
		  created date NOT NULL,
		  sql0 varchar(250) NOT NULL,
		  sql1 varchar(4000) NOT NULL,
		  params varchar(4000),
		  tracer varchar(4000),
		  timer decimal(16,6) NOT NULL
		)
</pre>
Uso: 
<pre>
	$conn->LogSQL(); // Habilita el registro
	  :
	$conn->Execute(...);
	  :
	$conn->LogSQL(false); // deshabilita el registro
	
	# Muestra un resumen de los resultados del registro
	$perf = NewPerfMonitor($conn);
	echo $perf->SuspiciousSQL();
	echo $perf->ExpensiveSQL();
</pre>
<p>Una limitante del registro es que el 'rollback' de la transaccion tambien impide que el
enunciado SQL se registre.
<p>
Si deseas otro nombre para la tabla a utilizar para almacenar los SQL, tendras que
invocar adodb_perf::table($tablename), donde $tablename es el nuevo nombre de la tabla
(tu tendras que crear la tabla manualmente). Un ejemplo:
<pre>
	include('adodb.inc.php');
	include('adodb-perf.inc.php');
	adodb_perf::table('my_logsql_table');
</pre>
Tambien ve los manuales <a href=docs-perf-es.htm>Monitor de rendimiento</a>. 
<p><b>Propiedades fnExecute y fnCacheExecute<a name="fnexecute" id="fnexecute"></a></b>
<p>Estas dos propiedades nos permiten definir funciones de 'cuello de botella' para todos
   los enunciados SQL procesados por ADOdb. Nos permite realizar estadisticas y 
   reescritura de los enunciados SQL.
<p><b>Ejemplos de fnExecute</b></p>
<p>A continuacion un ejemplo del uso de fnExecute para contar todos los 
   queries con cache y sin cache:</p>
<pre><font color="#006600"># $conn es el objeto de conexion</font>
function CountExecs($conn, $sql, $inputarray)
{
global $EXECS;

if (!is_array(inputarray)) $EXECS++;
<font color="#006600"># Maneja arreglos bidimensionales</font>
else if (is_array(reset($inputarray))) $EXECS += sizeof($inputarray);
else $EXECS++;
}

<font color="#006600"># $conn es el objeto de conexion</font>
function CountCachedExecs($conn, $secs2cache, $sql, $inputarray)
{<br>global $CACHED; $CACHED++;
}
<br>$conn = NewADOConnection('mysql');
$conn-&gt;Connect(...);
$conn-&gt;<strong>fnExecute</strong> = 'CountExecs';
$conn-&gt;<strong>fnCacheExecute</strong> = 'CountCachedExecs';
 :
 :<br><font color="#006600"># Despues de muchos enunciados sql:</font>`
printf(&quot;&lt;p&gt;Total de queries=%d; total en cache=%d&lt;/p&gt;&quot;,$EXECS+$CACHED, $CACHED);
</pre>
<p>La funcion fnExecute se llamada antes del que el sql sea examinado y ejecutado,
   por eso se puede reescribir el query. Si mandas como parametro un enunciado
   preparado entonces $sql es un arreglo (ver <a href="#prepare">Prepare</a>). 
   La funcion fnCacheExecute se ejecuta unicamente si el recordset se almacena en
   cache.  Los parametros de la funcion coinciden con las funciones Execute y
   CacheExecute, excepto que $this (el objeto conexion) se manda como primer
   parametro.
<p>Desde la version 3.91 de ADOdb 3.91, el comportamiento de fnExecute es diferente
   dependiendo de si la funcion definida regresa un valor. Si no regresa ningun valor
   el enunciado $sql se ejecuta como siempre. Esto es util para reescribir querys o
   para contar ejecuciones.
<p> Tambien puedes desear reemplazar la funcion Execute con una propia. En este
   caso, que tu funcion regrese un valor. Si se obtiene un valor, el valor
   se regresa inmediatamente sin ningun procesamiento. Esto lo uso ADodb internamente
   para implementar LogSQL().
<p> 
<hr>
<h3>Funciones de auxilio de ADOConnection</h3>
<p><b>BlankRecordSet<a name="blankrecordset"></a>([$queryid])</b></p>
<p>Ya no esta disponible, se quito desde laversion 1.99.</p>
<p><b>Concat<a name="concat"></a>($s1,$s2,....)</b></p>
<p>Genera la cadena de caracteres para concatenar $s1, $s2, etc. Emplea el texto
  en la propiedad concat_operator para generar la concatenacion. Omita la funcion
  si no se usa un caracter de concatenacion, como en MySQL.
<p>Regresa la cadena concatenada.
<p><b>DBDate<a name="dbdate"></a>($date)</b></p>
<p>Formatea el campo $<b>date</b> en un formato fecha que la base de datos acepte.
  Se emplea en enunciados INSERT/UPDATE; para enunciados SELECT emplee 
  <a href="#sqldate">SQLDate</a>. 
  El parametro $<b>date</b> puede ser un entero con la fecha Unix o una cadena en
  formato ISO Y-m-d. Emplea la propiedad fmtDate que contiene el formato a emplear.
  Si le menda como parametro null o false o '', genera un null de SQL.</p>
<p>Regresa la fecha como una cadena encomillada.
<pre>
    $sql = "select * from atable where created > ".$db->DBDate("$year-$month-$day");
    $db->Execute($sql);
</pre>
<p><b>BindDate<a name="binddate"></a>($date)</b></p>
<p>Formatea la fecha ($<b>date</b>) en formato que la base de datos acepte para variables posicionales.
Normalmente esto significa que la cadena no se entre comilla.
<pre>
    $sql = "select * from atable where created > ".$db->Param('0');
    // or
    $sql = "select * from atable where created > ?";
    $db->Execute($sql,array($db->BindDate("$year-$month-$day"));
</pre>
<p><b>DBTimeStamp<a name="dbtimestamp"></a>($ts)</b></p>
<p>Formatea el registro de tiempo $<b>ts</b> en un formato que acepte la base de
  datos, puede ser un entero de Unix o una cadena en el formato ISO Y-m-d H:i:s. 
  Emplea el valor de la propedad fmtTimeStamp, que contiene el formato a emplear.
  Si le menda como parametro null o false o '', genera un null de SQL.</p>
<p>Regresa el registro de tiempo como una cadena encomillada.</p>
<pre>
    $sql = "select * from atable where created > ".$db->DBTimeStamp("$year-$month-$day $hr:$min:$secs");
    $db->Execute($sql);
</pre>
<p><font><b>BindTimeStamp<a name="bindtimestamp"></a>($ts)</b></font></p>
<p><font>Formatea el resgistro de tiempo $<b>ts</b> en formato de variable posicional para ser aceptado por la
base de datos. Esto casi siempre significa que la cadena no sera encomillada.
<pre>
    $sql = "select * from atable where created > ".$db->Param('0');
    // or
    $sql = "select * from atable where created > ?";
    $db->Execute($sql,array($db->BindTimeStamp("$year-$month-$day $hr:$min:$secs"));
</pre>


<p><b>qstr<a name="qstr"></a>($s,[$magic_quotes_enabled</b>=false]<b>)</b></p>
<p>Encierra entre comillas una cadena a ser enviada a la base de datos.
  Puede verse extraño el parametro $<b>magic_quotes_enabled</b>, pero la idea es por
  si esta encomillando cadenas obtenidas por POST o GET, se puede mandar
  get_magic_quotes_gpc() como el segundo parametro.
  Esto nos asegura que la variable no se encomille dos veces, una por <i>qstr</i> 
  y la otra por <i>magic_quotes_gpc</i>.</p>
<p>Ej.<font face="Courier New, Courier, mono"> $s = $db-&gt;qstr(HTTP_GET_VARS['name'],get_magic_quotes_gpc());</font></p>
<p>Regresa la cadena encomillada.</p>
<p><b>Quote<a name="quote"></a>($s)</b></p>
<p>Encierra entre comillas la cadena $s, protegiendo el caracter especifico de 
   encomillado de la base de datos.
   Anteriormente verificaba el estado de 'magic quotes', pero se deshabilito desde la version
   3.31 para que sea compatible con el paquete DB de PEAR. 
<p><b>Affected_Rows<a name="affected_rows"></a>( )</b></p>
<p>Regresa el numero de renglones afectados por un enunciado update o delete. Regresa
   falso si la funcion no esta soportada.
<p>Actualmente no esta soportada para interbase/firebird. </p>
<p><b>Insert_ID<a name="inserted_id"></a>( )</b></p>
<p>Regresa el ultimo identificador de numeracion automatico insertado (serial).
   Regresa falso si la funcion no esta soportada.
<p>Unicamente soportado por bases de datos que manejan auto incrementos o identificador
   de objetos (OID) como PostgreSQL, actualmente MySQL y MS SQL Server. 
   PostgreSQL regresa el OID, que puede cambiar en una recarga de la base de datos.
<p><b>RowLock<a name="rowlock"></a>($table,$where)</b></p>
<p>Asegura el renglon de una tabla por la duracion de la transaccion. Por ejemplo,
   para asegurar el renglon $id de la tabla 'table1':
<pre>
	$DB->StartTrans();
	$DB->RowLock("table1","rowid=$id");
	$DB->Execute($sql1);
	$DB->Execute($sql2);
	$DB->CompleteTrans();
</pre>
<p>Funciona en db2, interbase, informix, mssql, oci8, postgres, sybase.
<p><b>MetaDatabases<a name="metadatabases"></a>()</b></p>
<p>Regresa un arreglo con la lista de bases de datos disponibles en el servidor. Debes
   de estar conectado al servidor.  Solo disponible para ODBC, MySQL y ADO.</p>
<p><b>MetaTables<a name="metatables"></a>($ttype = false, $showSchema = false, 
  $mask=false)</b></p>
<p>Regresa un arreglo de las tablas y vistas de la base de datos actual. 
  El arreglo omitira en lo posible las tablas del sistema.
  Para unicamente mostar tablas use db->MetaTables('TABLES'). 
  Para unicamente mostar vistas use $db->MetaTables('VIEWS'). 
  Actualmente el parametro $showSchema solo funciona para DB2, y cuando es verdadero,
  agerga el nombre del esquema a la tabla, ej. "SCHEMA.TABLE". </p>
<p>Se puede definir una mascara de coincidencia. Por ejemplo, con $mask = 'TMP%' solo
  encontrara las tablas que empiecen con 'TMP'.
  Por lo pronto solo mssql, oci8, odbc_mssql y postgres* manejan el parametro $mask. 
<p><b>MetaColumns<a name="metacolumns"></a>($table,$toupper=true)</b></p>
<p>Regresa un arreglo de objetos de la clase ADOFieldObject, un objeto por cada columna
  de la tabla $table. Cada instancia tiene definidos las propiedades (name, type, max_length).
  Actualmente Sybase no reconoce los tipos de fecha y ADO no puede identificar el
  tipo adecuado de datos (por lo que se identifican como 'varchar').
 <p> El parametro $toupper determina si hay que convertir a mayusculas el nombre de 
 la tabla (requerido por algunas bases de datos).
 <p>Para el manejo de esquemas, en el parametro $table mande el valor "$schema.$tablename". 
   Estos solo funciona en algunas bases de datos.
<p><b>MetaColumnNames<a name="metacolumnames"></a>($table)</b></p>
<p>Regresa un arreglo con los nombres de las columnas de la tabla $table. Desde ADOdb 4.22, 
   es un arreglo asociativo con las llaves en mayusculas.
<p> Es decir, array('FIELD1' => 'Field1', 'FIELD2'=>'Field2')
<p>
<p><b>MetaPrimaryKeys<a name="metaprimarykeys"></a>($table, 
  $owner=false)</b>
<p>Regresa un arreglo con el nombre de las columnas que forman la llave primaria
   de la tabla $table. Actualmente manejado por mysql, odbc (including db2, odbc_mssql, etc), 
   mssql, postgres, interbase/firebird, oci8. 
<p>Las vistas (y algunas tablas) tienen llave primaria, pero algunas veces esta
   informacion no esta disponible para la base de datos.
   Tu puedes definir una funcion ADODB_View_PrimaryKeys($databaseType, $database, $view, $owner)
   que regrese el arreglo conteniendo los campos que forman la llave primaria.
   Si esta funcion existe sera invocada cuando MetaPrimaryKeys() no pueda encontrar
   la llave primaria para tabla o vista.
<pre>
// En este ejemplo: dbtype = 'oci8', $db = 'mydb', $view = 'dataView', $owner = false 
function ADODB_View_PrimaryKeys($dbtype,$db,$view,$owner)
{
	switch(strtoupper($view)) {
	case 'DATAVIEW': return array('DATAID');
	default: return false;
	}
}

$db = NewADOConnection('oci8');
$db->Connect('localhost','root','','mydb'); 
$db->MetaPrimaryKeys('dataView');
</pre>
<p><b>ServerInfo<a name="serverinfo" id="serverinfo"></a>($table)</b>
<p>Regresa un arreglo asociativo con dos elementos 'description' y 'version'. 
  El elemento 'description' contiene una cadena con la descripcion de la base de datos.
  El elemento 'version' contiene una cadena con el numero de version.
<p><b>MetaForeignKeys<a name="metaforeignkeys"></a>($table, $owner=false, $upper=false)</b> 
<p>Regresa un arreglo asociativo con las llaves foraneas (foreign keys) de la tabla.
   o falso si no esta soportado.
   Por ejemplo, si la tabla 'empleados' tiene una llave foranea 'empleados.empl_dept' apunta
    a 'departamentos.dept_clav', y empleados.empl_puesto=organigrama.orga_puesto y 
    empleados.empl_cat=organigrama.orga_cat, 
    entonces $conn->MetaForeignKeys('empleados') obtendra como resultado:
<pre>
	array(
		'departamentos' => array('empl_dept=dept_clav'),
		'organigrama' => array('empl_puesto=orga_puesto','empl_cat=orga_cat')
	)
</pre>
<p>Opcionalmente el dueño de la tabla o vista se puede definir en $owner.
   Si $upper es verdadero entonces el nombre de las tables (las llaves del arreglo) 
   se convierten a mayusculas.
<hr>
<h2>ADORecordSet<a name="adorecordset"></a></h2>
<p>Cuando se ejectuta satisfactoriamente un enunciado SQL con el metodo
   <font face="Courier New, Courier, mono">ADOConnection-&gt;Execute($sql),</font> se
   obtiene un objeto ADORecordSet. Este objeto contiene: un cursor virtual para podernos
   mover de renglon en renglon, funciones para obtener informacion acerca de las columnas
   y sus tipos de datos, y funciones auxiliares para el formateo de los resultados para
   ser mostrados al usuario.
<h3>Campos/propiedades de ADORecordSet</h3>
<p><b>fields: </b>Arreglo que contiene el renglon actual. No es asociativo, sino un arreglo
   indexado del 0 al (columnas - 1). Vea tambien la funcion <b><a href="#fields">Fields</a></b>, 
   que se comprota como un arreglo asociativo.</p>
<p><b>dataProvider</b>: El mecanismo subyacente empleado para conectarse a la base de
  datos. Normalmete vale <b>native</b>, a menos que sea <b>odbc</b> o <b>ado</b>.</p>
<p><b>blobSize</b>: Tamaño maximo de un objeto char, string o varchar antes de que
   se considere como un Blob (Los Blobs se deberan mostar en textareas). Vea
   la funcion <a href="#metatype">MetaType</a> 
  function.</p>
<p><b>sql</b>: Contiene el enunciado sql empleado para generar este conjunto de datos.</p>
<p><b>canSeek</b>: Con valor verdadero si la funcion Move( ) funciona..</p>
<p><b>EOF</b>: Verdadero si se ha navegado el cursor despues del ultimo registro.</p>
<h3>Funciones/metodos de ADORecordSet</h3>
<p><b>ADORecordSet( )</b></p>
<p>Constructor. Normalmente nunca hay que llamar a esta funcion.</p>
<p><b>GetAssoc<a name="getassoc"></a>([$force_array])</b></p>
<p>Genera un arreglo asociativo del recordset. Observe que esta funcion tambien esta
  <a href="#getassoc1">disponible</a> en el objeto de conexion. Mas detalles se pueden
  encontar ahi.
<p><b>GetArray<a name="getarray"></a>([$number_of_rows])</b></p>
<p>Genera un arreglo bidimensional de registros desde la position actual del cursor,
  indexado desde 0 a ($number_of_rows - 1). Si no se define $number_of_rows, se
  indexa hasta el final de recordset (EOF).
<p><b>GetRows<a name="getrows"></a>([$number_of_rows])</b></p>
  Genera un arreglo bidimensional de registros desde la posicion actual del cursor,
  Sinomimo de GetArray() para tener compatibilidad con Microsoft ADO. 
<p> <b>GetMenu<a name="getmenu"></a>($name, [$default_str=''], [$blank1stItem=true], 
  [$multiple_select=false], [$size=0], [$moreAttr=''])</b></p>
<p>Genera un menu HTML (&lt;select&gt;&lt;option&gt;&lt;option&gt;&lt;/select&gt;). 
  La primera columna del recordset (fields[0]) contiene el texto a desplegar en
  la etiqueta option. Si el recordset tiene mas de 1 columna, la segunda columna
  (fields[1]) es el valor a enviar al servidor Web. La variable del menu tendra
  el nombre $<i>name</i>. 
<p> Si esta definido $<i>default_str</i>, entonces si $<i>default_str</i> == fields[0], 
  entonces ese campo se selecciona. Si $<i>blank1stItem</i> es verdadero, la primera
  opcion esta en blanco. Tambien se le puede poner un texto a la primera opcion con
  $blank1stItem = "$valor:$texto".</p>
<p>$<i>Default_str</i> puede ser un arreglo para una caja de opcion multiple.</p>
<p>Para obtener una caja, asignele a $<i>size</i> un valor diferente de cero (o 
   mande $default_str como un arreglo). Si $<i>multiple_select</i> es verdadero entonces
   se generara un caja con $<i>size</i> elementos (o si $size==0, con 5 elementos) visibles,
   y se regresera un arreglo al servidor. Finalmente emplee $<i>moreAttr </i> para agregar
   atributos adicionales como javascript o styles. </p>
<p>Ejemplo de Menu 1: <code>GetMenu('menu1','A',true)</code> genera el menu: 
  <select name='menu1'>
    <option> 
    <option value=1 selected>A 
    <option value=2>B 
    <option value=3>C 
  </select>
  con los datos (A,1), (B,2), (C,3). Tambien vea el <a href="#ex5">ejemplo 5</a>.</p>
<p>Ejemplo de Menu 2: Con los mismo datos, <code>GetMenu('menu1',array('A','B'),false)</code> 
   generara un menu con A y B seleccionados: <br>
  <select name='menu1' multiple size=3>
    <option value=1 selected>A 
    <option value=2 selected>B 
    <option value=3>C 
  </select>
<p> <b>GetMenu2<a name="getmenu2"></a>($name, [$default_str=''], [$blank1stItem=true], 
  [$multiple_select=false], [$size=0], [$moreAttr=''])</b></p>
<p>Es casi indentica a GetMenu, excepto que $<i>default_str</i> se compara contra 
  fields[1] (el valor de la opcion).</p>
<p>Ejemplo de Menu 3: Con el conjunto de datos del ejemplo 1, <code>GetMenu2('menu1',array('1','2'),false)</code> 
  generara un menu con A y B seleccionados como en el ejemplo 2, pero en esta ocasion
  la seleccion se baso en la segunda columna, que contiene el valor a regresar al
  servidor Web.
<p><b>UserDate<a name="userdate"></a>($str, [$fmt])</b></p>
<p>Convierte la cadena de caracteres con una fecha  $<i>str</i> a otro formato fecha. 
   El formato de fecha es Y-m-d o un timestamp de Unix. 
   El valor por omision de $<i>fmt</i> es Y-m-d.</p>
<p><b>UserTimeStamp<a name="usertimestamp"></a>($str, [$fmt])</b></p>
<p>Convierte la cadena de caracteres con un timestamp $<b>str</b> a otro formato.
   El formato de timestamp es Y-m-d H:i:s, como en '2002-02-28 23:00:12', o un timestamp
   de Unix. UserTimeStamp llama a UnixTimeStamp para analizar $<i>str</i>. El valor
   por omision de $<i>fmt</i> es to Y-m-d H:i:s. 
</p>
<p><b>UnixDate<a name="unixdate"></a>($str)</b></p>
<p>Analiza la cadena $<b>str</b> por una fecha y la regresa en el formato unix para mktime 
  (es decir un numero indicando el numero de segundos desde el 1° de enero de 1970).
   Supone que la fecha tiene formato Y-m-d H:i:s, excepto para Sybase y Microsoft SQL Server, 
   donde tambien se acepta M d Y (El mes a 3 letras es controlado por un arreglo global
   que puede necesitar tropicalizacion).
<p>La funcion esta disponible tanto para ADORecordSet y ADOConnection desde 1.91.</p>
<p><b>UnixTimeStamp<a name="unixtimestamp"></a>($str)</b></p>
<p>Analiza la cadena $<b>str</b> por un timestap y lo regresa en el formato unix para mktime
  (es decir un numero indicando el numero de segundos desde el 1° de enero de 1970).
  Espera la fecha en formato "Y-m-d, H:i:s" (1970-12-24, 00:00:00) o "Y-m-d H:i:s" 
  (1970-12-24 00:00:00) o "YmdHis" (19701225000000), excepto para Sybase y Microsoft 
  SQL Server, donde tambien se acepta "M d Y h:i:sA" (Dec 25 1970 00:00:00AM), 
  (El mes a 3 letras se controla por un arreglo global que puede necesitar tropicalizacion).
<p>La funcion esta disponible tanto para ADORecordSet y ADOConnection desde 1.91.</p>
<p><b>OffsetDate<a name="offsetdate"></a>($dayFraction, $basedate=false)</b>
<p>Regresa una cadena con la funcion SQL nativa para calcular fechas futuras y pasadas
  en base $basedate. Si $basedate no esta definida entonces se toma la fecha actual 
  (a las 12 de la noche). Regresa la cadena SQL que realiza los calculos cuando
  se procesa por Execute(). 
<p>Por ejemplo, en Oracle, para encontrar la fecha que esta 2.5 dias en el futuro:
<pre># obtener fecha una semana en el futuro
$fld = $conn-&gt;OffsetDate(7); // Regresa &quot;(trunc(sysdate)+7&quot;)</pre>
<pre># obtener fecha y hora que esta 60 horas en el futuro
$fld = $conn-&gt;OffsetDate(2.5, $conn-&gt;sysTimeStamp);	// regresa &quot;(sysdate+2.5)&quot;
</pre>
<p> Esta funcion esta disponible en los driverrs mysql, mssql, oracle, oci8 y postgresql 
  desde 2.13. Puede funcionar con otros drivers siempre y cuando permitan aritmetica
  de fechas.</p>
<p><b>SQLDate<a name="sqldate"></a>($dateFormat, $basedate=false)</b>
Regresa una cadena que contiene la funcion SQL nativa para formatear una fecha o el campo
   fecha $basedate. Es usado en enunciados SELECT. Para enunciados INSERT/UPDATE  
   use <a href="#dbdate">DBDate</a>. Emplea un formato con mayusculas/minusculas en
   $dateFormat, que maneja: 
<pre>
 Y: A&ntilde;o a 4 digitis
 Q: Trimestre (1-4)
 M: Mes (Jan-Dec)
 m: Mes (01-12)
 d: Dia (01-31)
 H: Hora (00-23)
 h: Hora (1-12)
 i: Minuto (00-59)
 s: Segundo (00-60)
 A: Indicador de AM/PM</pre>
<p>Todos los demas caracteres se tratan como cadena. Se puede usar \ para escapar caracteres.
  Disponible en algunas bases de datos, incluyendo  mysql, postgresql, mssql, oci8 y 
  DB2. 
<p>Es util para escribir enunciados sql portable que hacen GROUP BY por fechas.
  Por ejemplo para mostrar el costo total de los bienes vendidos por cada trimestre
  (las fecha estan en el campo llamado postdate):</p>
<pre>
 $sqlfn = $db->SQLDate('Y-\QQ','postdate'); # obtiene el sql que formatea postdate 
 $sql = "SELECT $sqlfn,SUM(cogs) FROM table GROUP BY $sqlfn ORDER BY 1 desc";
 </pre>
<p><b>MoveNext<a name="movenext"></a>( )</b></p>
<p>Mueve el cursor al siguiente renglon. El arreglo <i>$this->fields</i> se actualiza
  automaticamente. Regresa falso si no lo pudo hacer (normalmente debido a que se
  encontrol el EOF), en caso contrario regresa verdadero.
<p>Si se alcanzo el EOF, entonces el arreglo $this->fields tiene valor falso (esto funciona
   consistentemente a partir de ADOdb 3.30). Para tener el comportamiento que habia antes
   de la version 3.30 en $this->fields (en EOF), ponga la variable global 
   $ADODB_COMPAT_FETCH = true.</p>
<p>Ejemplo:</p>
<pre>$rs = $db-&gt;Execute($sql);
if ($rs) 
	while (!$rs-&gt;EOF) {
 		ProcessArray($rs->fields);	
		$rs->MoveNext();
	} </pre>
<p><b>Move<a name="move"></a>($to)</b></p>
<p>Mueve el cursor interno al renglon $<b>to</b>. En numero de renglon empieza en 0,
  es decir 0 es el primer renglon. El arreglo  <b>fields</b> es actualizado automaticamente.
  Para aquellas bases de datos que no manejan internamente la navegacion, ADOdb simulara
  la navegacion para adelante. Algunas bases de datos no manejan la navegacion para 
  atras. Si $<b>to</b> esta despues del EOF, $<b>to</b> se movera al final del RecordSet 
  en la mayoria de las bases de datos. Algunas bases de datos poco claras usando odbc pueden
  no comportarse de esta manera.
<p>Observacion: Esta funcion emplea <i>posicionamiento absoluto </i>, a comparacion de
   Microsoft's ADO.</p>
<p>Regresa verdadero o falso. Si es falso, el cursor interno no se mueve en la mayoria de las
   implementaciones, en cuyo caso AbsolutePosition( ) regresara la ultima posicion del
   cursor antes del Move( ). </p>
<p><b>MoveFirst<a name="movefirst"></a>()</b></p>
<p>Internamente invoca Move(0). Algunas bases de datos no manejan esta funcion.
<p><b>MoveLast<a name="movelast"></a>()</b></p>
<p>Internamente llama Move(RecordCount()-1). Algunas bases de datos no manejan esta funcion.
<p><b>GetRowAssoc</b><a name="getrowassoc"></a>($toUpper=true)</p>
<p>Regresa un arreglo asociativo conteniendo el renglon actual. Las llaves del arreglo son
   los nombres de las columnas. El nombre de las columnas esta en mayusculas para
   facilitar el acceso. Para obtener el siguiente renglon todavia es necesario
   invocar MoveNext().
<p>Por ejemplo:<br>
  Array ( [ID] => 1 [FIRSTNAME] => Caroline [LASTNAME] => Miranda [CREATED] => 
  2001-07-05 ) </p>
<p>Nota: no use GetRowAssoc() con $ADODB_FETCH_MODE = ADODB_FETCH_ASSOC. 
  debido a que tienen la misma funcionalidad e interfiere uno con el otro.
<p><b>AbsolutePage<a name="absolutepage"></a>($page=-1) </b>
<p>Regresa la pagina indicada. Requiere que se haya llamado PageExecute() o CachePageExecute(). 
  Ver <a href=#ex8>Ejemplo 8</a>.</p>
<p><b>AtFirstPage<a name="atfirstpage">($status='')</a></b></p>
<p>Regresa verdadero si esta en la primera pagina, (en base a 1). 
   Requiere que se haya llamado a PageExecute() o CachePageExecute().
   ver <a href=#ex8>Ejemplo 8</a>.</p>
<p><b>AtLastPage<a name="atlastpage">($status='')</a></b></p>
<p>Regresa verdadero si esta en la ultima pagina, (en base a 1). 
   Requiere que se haya llamado a PageExecute() o CachePageExecute().
   ver <a href=#ex8>Ejemplo 8</a>.</p>
<p><b>Fields</b><a name="fields"></a>(<b>$colname</b>)</p>
<p>Regresa el valor de la columna $<b>colname</b>. Al nombre de la columna no le afectan
   las mayusculas.
<p>Esta funcion solo esta por comodidad. Para un mejor rendimiento use
   <a href="#adodb_fetch_mode">$ADODB_FETCH_MODE</a>. </p>
<p><b>FetchRow</b><a name="fetchrow"></a>()</p>
<p>Regresa un arreglo conteniendo el renglon actual, or falso si es EOF.
  Internamente FetchRow( ) se mueve al siguiente renglon despues de regresar el renglon
  actual.
<p><b>ADVERTENCIA</b>: No mezcle FetchRow() con MoveNext().
<p>Uso:
<pre>$rs = $db-&gt;Execute($sql);
if ($rs)
	while ($arr = $rs-&gt;FetchRow()) &#123;
	   &nbsp;&nbsp;# process $arr	
	&#125;</pre>
<p><b>FetchInto</b><a name="fetchinto"></a>(<b>&amp;$array</b>)
<p>Pone en el arreglo $array el renglon actual. Regresa un objeto PEAR_Error 
  si EOF, 1 si es correcto (la constante DB_OK). Si PEAR no esta definido regresa
  falso cuando encuentra EOF. Internamente FetchInto() se mueve al siguiente
  registro despues de regresar el renglon actual.
<p> Es mas facil de usar FetchRow(). Vea arriba.
<p><b>FetchField<a name="fetchfield"></a>($column_number)</b></p>
<p>Regresa un objeto conteniendo <b>name</b>, <b>type</b> and <b>max_length</b> 
  de el campo solicitado. Si max_length no se pueden determinar con confianza, tendra el
  valor de -1. El numero de columna esta en base a cero (la primer columna es 0).
  Ver el <a href="#ex2">ejemplo 2.</a></p>
<p><b>FieldCount<a name="fieldcount"></a>( )</b></p>
<p>Regresa el numero de campos (columnas) en el recordset.</p>
<p><b>RecordCount<a name="recordcount"></a>( )</b></p>
<p>regresa el numero de renglones en el recordset. Si el numero de registros obtenidos 
  no se puede determinar del API de la base de datos, se leeran todos los renglones
  para poderse contar. Esta lectura puede ser deshabilitada (por rendimiento) asignandole
  la variable $ADODB_COUNTRECS = false. Cuando esta deshabilitada, RecordCount( ) regresara
  -1 en algunas bases de datos.
  Vea arriba la lista de bases de datos soportadas para mas detalle.
<p> RowCount es un sinonimo de RecordCount.</p>
<p><b>PO_RecordCount<a name="po_recordcount"></a>($table, $where)</b></p>
<p>Regresa el numero de registros en el recordset. Si la base de datos no lo maneja, 
   ejecutara un SELECT COUNT(*) en la tabla $table, con el criterio dado $where, para
   obtener una estimacion del tamaño del recordset.</p>
<p>$numrows = $rs-&gt;PO_RecordCount(&quot;articles_table&quot;, &quot;group=$group&quot;);</p>
<b> NextRecordSet<a name="nextrecordset" id="nextrecordset"></a>()</b> 
<p>Para las bases de datos que permiten que un query regrese varios recordsets,
  esta funcion permite cambiarse al siguiente recordset. Unicamente soportada para el
  driver de mssql.
<pre>
$rs = $db-&gt;Execute('execute return_multiple_rs');
$arr1 = $rs-&gt;GetArray();
$rs-&gt;NextRecordSet();
$arr2 = $rs-&gt;GetArray();</pre>
<p><b>FetchObject<a name="fetchobject"></a>($toupper=true)</b></p>
<p>Regresa el renglon actual como un object. Si se manda $toupper = true, entonces
  los campos de los objetos estaran en mayusculas. Nota. La nueva funcion
  FetchNextObject() es el metodo recomendado para accesar los renglones como
  objetos. Vea a continuacion.
<p><b>FetchNextObject<a name="fetchnextobject"></a>($toupper=true)</b></p>
<p>Obtiene el renglon actual como un objeto y automaticamente avanza al siguiente 
   renglon. Regresa falso si esta al final del archivo (EOF). Si se manda
   $toupper = true, entonces los campos del objeto estaran en mayusculas.
<pre>
$rs = $db->Execute('select firstname,lastname from table');
if ($rs) &#123;
	while ($o = $rs->FetchNextObject()) &#123;
		print "$o->FIRSTNAME, $o->LASTNAME&lt;BR>";
	&#125;
&#125;
</pre>
<p>Hay una concesion en la velocidad por usar FetchNextObject(). Si el rendimiento
   es importante, se deben de accesar los renglones con el arreglo <code>fields[]</code>. 
<p><b>FetchObj<a name="fetchobj" id="fetchobj"></a>()</b> 
<p>Regresa el renglon actual como un objeto. Los nombres de los campos no se convierten
   a mayusculas al contrario de FetchObject. 
<p><b>FetchNextObj<a name="fetchnextobj" id="fetchnextobj"></a>()</b> 
<p>Regresa el renglon actual como un objeto y se mueve al siguiente registro.
   Si hay EOF regresa falso. Los campos no se convierten a mayusculas al contrario
   de FetchNextObject. 
<p><b>CurrentRow<a name="currentrow"></a>( )</b></p>
<p>Regresa el numero del renglon actual, Regresa 0 si es el primer renglon.
<p><b>AbsolutePosition<a name="abspos"></a>( )</b></p>
<p>Sinonimo de <b>CurrentRow</b> para compatibilidad con ADO. Regresa el numero del
   renglon actual. 0 si es el primer renglon.
<p><b>MetaType<a name="metatype"></a>($nativeDBType[,$field_max_length],[$fieldobj])</b></p>
<p>Determina el meta tipo <i>generic</i> del tipo de campo nativo $<b>nativeDBType</b> 
  de la base de datos, y la longitud del campo $<b>field_max_length</b>. 
  Toma en cuenta que field_max_length puede ser -1 si no es conocido. El objeto del campo
  regresado por FetchField() puede ser pasado a $<b>fieldobj</b> o como el primer
   parametro <b>$nativeDBType</b>. 
  Es util para bases de datos como <i>mysql</i> que tienen propiedades adicionales
  en el objeto de campo como <i>primary_key</i>. </p>
<p>Emplea el campo <b>blobSize</b> y lo compara con $<b>field_max_length</b> 
   para determinar si campo caracter es realmente un blob.
   Por ejemplo, $db-&gt;MetaType('char') will return 'C'. 
<p>Regresa:</p>
<ul>
  <li><b>C</b>: Campo caracter que debe ser mostrador en una etiqueta &lt;input type=&quot;text&quot;&gt;. </li>
  <li><b>X</b>: Clob (character large objects), o campos de textos largos que deberia de ser
      mostrado en &lt;textarea&gt;</li>
  <li><b>D</b>: Campo fecha</li>
  <li><b>T</b>: Campo Timestamp o datetime</li>
  <li><b>L</b>: Campo logico (boleano o de bit)</li>
  <li><b>N</b>: Campo numerico. Incluye decimal, numeric, punto flotante, y real. </li>
  <li><b>I</b>: Campo entero. </li>
  <li><b>R</b>: Campo contador o auto-incremento. Debe de ser numerico.</li>
  <li><b>B</b>: Blob o binario objeto largo.</li>
</ul>
<p> Desde ADOdb 3.0, MetaType acepta $fieldobj como el primer parametro, en lugar 
    de $nativeDBType. 
<p><b>Close( )<a name="rsclose"></a></b></p>
<p>Cierra el recordset, limpia toda la memoria y recursos asociados con el recordset. 
<p>
Si no se esta usando la administracion de memoria, no hay necesidad de llamar a esta 
funcion ya que los recordset son cerrados por PHP al final del script.
Los enunciados SQL como INSERT/UPDATE/DELETE no regresan realmente un recordset, por lo
que no hay que llamar a Close() para esos enunciados SQL.</p>
<hr>
<h3>function rs2html<a name="rs2html"></a>($adorecordset,[$tableheader_attributes], 
  [$col_titles])</h3>
<p>Esta es una funcion independiente (rs2html = recordset a html) que es similar a
  la funcion PHP <i>odbc_result_all</i>, imprime un ADORecordSet, $<b>adorecordset</b> 
  como una tabla HTML. El parametro $<b>tableheader_attributes</b> nos permite 
  controlar los atributos de la tabla (<i>cellpadding</i>, <i>cellspacing</i> y
  <i>border</i>). Finalmente se puede reemplazar el nombre de las columnas
  de la base de datos con nuestros propios titulos con el arreglo $<b>col_titles</b>. 
  Esta diseñado mas como un mecanismo rapido de depuracion, no como un visor
  de recordsets en un sistema en produccion.
<p>Se necesita incluir el archivo <i>tohtml.inc.php</i>.</p>
<p>Ejemplo de rs2html:<b><font color="#336600"><a name="exrs2html"></a></font></b></p>
<pre><b><font color="#336600">&lt;?
include('adodb/tohtml.inc.php')</font></b>; # Carga el codigo de ADOdb
<b>include</b>('adodb/adodb.inc.php'); # Carga el codigo de ADOdb
$<font color="#663300">conn</font> = &amp;ADONewConnection('mysql');   # crea la conexion 
$<font color="#663300">conn</font>->PConnect('localhost','userid','','agora');# se conecta a agora db
$<font color="#663300">sql</font> = 'select CustomerName, CustomerID from customers'; 
$<font color="#663300">rs</font>   = $<font color="#663300">conn</font>->Execute($sql); 
<font color="#336600"><b>rs2html</b></font><b>($<font color="#663300">rs</font>,'<i>border=2 cellpadding=3</i>',array('<i>Customer Name','Customer ID</i>'));
?&gt;</b></pre>
<hr>
<h3>Diferencias entre la libreria ADOdb y Microsoft ADO<a name="adodiff"></a></h3>
<ol>
  <li>ADOdb unicamente maneja recordsets creados por el objeto conexion. Los recordsets 
    no pueden ser creados independientemente.
  <li>Las propiedades de ADO se implementan como funciones en ADOdb. 
    Esto hace mas sencillo de implementar cualquier funcionalidad mejorada de ADO en el futuro.
  <li>La funcion  <font face="Courier New, Courier, mono">ADORecordSet-&gt;Move()</font> 
    de ADOdb emplea posicionamiento absoluto, no relativo. Los bookmarks no estan
    soportados.
  <li><font face="Courier New, Courier, mono">ADORecordSet-&gt;AbsolutePosition() 
    </font>no puede ser usada para mover el cursor del registro.</li>
  <li>Los objetos de parametros de ADO no estan soportados. En su lugar existe
     la funcion ADOConnection::<a href="#parameter">Parameter</a>( ), la cual proporciona
     una interfase mas sencilla para nombrar parametros preparados e invocar procedimientos
     almacenados.
  <li>Las propiedades del recordset para paginacion estan disponibles, pero implementados
    como en el <a href=#ex8>Ejemplo 8</a>.</li>
</ol>
<hr>
<h1>Guia para crear manejadores de bases de datos<a name="driverguide"></a></h1>
<p>Aqui se describe como crear una clase para conectarse a una nueva base de datos. Para
   asegurarse que no hay duplicidad de trabajo, por favor mandemelo por correo a
   jlim#natsoft.com.my si decies crear una de esas clases.</p>
<p>Primero decide en un nombre en minusculas para noombrar al tipo de la base de datos.
   Digamos que se va a llamar 'xbase'. </p>
<p>Entonces hay que crear dos clases ADODB_xbase y ADORecordSet_xbase en el archivo
   adodb-xbase.inc.php.</p>
<p>La manera mas sencilla de crear un driver de base de datos es adaptando un driver
  ODBC existente. Entonces solo tenemos que crear una clase <i>ADODB_xbase extends ADODB_odbc</i> 
  que maneja los formatos de <b>date</b> y <b>timestamp</b>, el operador de <b>concatenacion</b> 
  , <b>true</b> y <b>false</b>. Para la clase <i> ADORecordSet_xbase extends 
  ADORecordSet_odbc </i> se necesita cambiar la funcion <b>MetaType</b>. Para un ejemplo
  ver <b>adodb-vfp.inc.php</b>.</p>
<p>Los mas complicado es un driver nuevo que se conecta a una extension de PHP nueva.
  En ese caso necesitaras implementar varias funciones, Afortunadamente, no tienes
  que modificar la mayoria del codigo comlejo. Unicamente necesitas reescribir algunas
  funciones prototipo. Ve <b>adodb-mysql.inc.php</b> para un ejemplo.</p>
<p>El formato por default de ADOdb es internamente YYYY-MM-DD (Ansi-92). Todas las
  fechas se deben de convertir a ese formato cuando se pasen a una funcion ADOdb de
  fecha. Ve el ejemplo de Oracle que usa ALTER SESSION para cambiar el formato de fecha
  en _pconnect y _connect.</p>
<p><b>Funciones en ADOConnection a Sobreescribir</b></p>
<p>La definicion de un constructor para la funcion ADOConnection derivada es opcional. 
  No hay necesidad de llamar el conctructor de la clase base.</p>
<p>_<b>connect</b>: Implementacion de bajo nivel del Connect. Regresa true o false. 
  Debe de asignar _<b>connectionID</b>.</p>
<p>_<b>pconnect:</b> Implementacion de bajo nivel de PConnect. Regresa true o false. 
  Debe de asignar _<b>connectionID</b>.</p>
<p>_<b>query</b>: Ejecuta un enunciado SQL. Regresa queryID, o false.</p>
<p>_<b>close: </b>Cierra la conexion -- PHP debe de limpiar todos los recordsets. 
</p>
<p><b>ErrorMsg</b>: Almacena el mensaje de error en la variable privada _errorMsg. 
</p>
<p><b>Campos de ADOConnection a inicializar</b></p>
<p>_<b>bindInputArray</b>: Con valor true si se permite la liga (binding) de parametros
  para enunciados SQL de insert y update usando ?.</p>
<p><b>fmtDate</b></p>
<p><b>fmtTimeStamp</b></p>
<p><b>true</b></p>
<p><b>false</b></p>
<p><b>concat_operator</b></p>
<p><b>replaceQuote</b></p>
<p><b>hasLimit</b> maneja SELECT * FROM TABLE LIMIT 10 de MySQL.</p>
<p><b>hasTop</b> maneja el estilo de Microsoft SELECT TOP 10 * FROM TABLE.</p>
<p><b>Funciones de ADORecordSet a sobreescribir</b></p>
<p>Se necesita crear un constructor de tu clase derivada de ADORecordSet que invoque al
  constructor de la clase padre.</p>
<p><b>FetchField: </b> como se documento anteriormente en ADORecordSet</p>
<p>_<b>initrs</b>: inicializacion de bajo nivel del recordset: inicializa los campos
 _<b>numOfRows</b> y _<b>numOfFields</b> -- invocada por el constructor.</p>
<p>_<b>seek</b>: busca un registro en particular. No carga los datos en el arreglo de
  campos. Eso lo hace _fetch. Regresa true o false. Observe que algunas implementaciones
  como Interbase no manejan seek. Poner canSeek a false.</p>
<p>_<b>fetch</b>: Obtiene un renglon usando la funcion de la extension de la base de datos 
  y avanza al siguiente renglon. Carga el arreglo <b>fields</b>. Si el parametro
  $ignore_fields es true entonces no hay necesidad de cargar el arreglo <b>fields</b>, 
  solo se mueve al siguiente renglon. Regresa true o false.</p>
<p>_<b>close</b>: Cierra el recordset</p>
<p><b>Fields</b>: es el arreglo regresado por la extension PHP no es un arreglo asociativo,
  tendras que reescribirlo. Ve adodb-odbc.inc.php para un ejemplo.
  Para bases de datos como MySQL y MSSQL donde se obtiene un arreglo asociativo, no hay
  necesidad de reescribir la funcion.</p>
<p><b>Campos de ADOConnection a inicializar</b></p>
<p>canSeek: Con valor true si la funcion _seek funciona.</p>
<h2>Optimizando PHP</h2>
Para informacion para optimizar PHP, lea este articulo acerca de 
<a href="http://phplens.com/lens/php-book/optimizing-debugging-php.php">Optimizando PHP</a>.</p>

<h2>Bitacora de Cambios (Change Log)<a name="Changes"></a><a name="changes"></a><a name="changelog"></a></h2>
<p><a name="4.92"></a><b>4.92 29 Aug 2006</b>
<P>Added IgnoreErrors() to bypass default error handling.
<p>The _adodb_getcount() function in adodb-lib.inc.php, some ORDER BY bug fixes.
<p>For ibase and firebird, set  $sysTimeStamp = "CURRENT_TIMESTAMP".
<p>Fixed postgres connection bug: http://phplens.com/lens/lensforum/msgs.php?id=11057.
<p>Changed CacheSelectLimit() to flush cache when $secs2cache==-1 due to complaints from other users. 
<p>Added support for using memcached with CacheExecute/CacheSelectLimit. Requires memcache module PECL extension. Usage:
<pre>
$db = NewADOConnection($driver);
$db->memCache = true; /// should we use memCache instead of caching in files
$db->memCacheHost = 126.0.1.1; /// memCache host
$db->memCachePort = 11211; /// this is default memCache port
$db->memCacheCompress = false; /// Use 'true' to store the item compressed (uses zlib)

$db->Connect(...);
$db->CacheExecute($sql);
</pre>
<p>Implemented Transpose() for recordsets. Recordset must be retrieved using ADODB_FETCH_NUM. First column becomes the 
column name.
<pre>
$DB = NewADOConnection('mysql');
$DB->Connect(...);
$DB->SetFetchMode(ADODB_FETCH_NUM);
$rs = $DB->Execute('select productname,productid,unitprice from products limit 10');
$rs2 = $DB->Transpose($rs);
rs2html($rs2);
</pre>
<p><a name="4.91"></a><b>4.91 2 Aug 2006</b>
<p>Major session code rewrite .... See session docs.
<p>PDO bindinputarray was not set properly for MySQL (changed from true to false).
<p>Changed CacheSelectLimit() to re-cache when $secs2cache==0. This is one way to flush the cache when SelectLimit is called.
<p>Added to quotes to mysql  and mysqli: "SHOW COLUMNS FROM `%s`";
<p>Removed accidental optgroup handling in GetMenu().
<a>Fixed ibase _BlobDecode for php5 compat, and also mem alloc issues for small blobs, thx salvatori#interia.pl
<p>Mysql driver OffsetDate() speedup, useful for adodb-sessions.
<p>Fix for GetAssoc() PHP5 compat. See http://phplens.com/lens/lensforum/msgs.php?id=15425
<p>Active Record - If inserting a record and the value of a primary key field is null, then we do not insert that field in as we assume it is an auto-increment field. Needed by mssql.
<p>Changed postgres7 MetaForeignKeys() see http://phplens.com/lens/lensforum/msgs.php?id=15531
<p>DB2 will now return db2_conn_errormsg() when it is a connection error. 
<p><a name="4.90"></a><b>4.90 8 June 2006</b>
<p>Changed adodb_countrec() in adodb-lib.inc.php to allow LIMIT to be used as a speedup to reduce no of records counted.
<p>Added support for transaction modes for postgres and oci8 with SetTransactionMode(). 
These transaction modes affect all subsequent transactions of that connection.
<p>Thanks to Halmai Csongor for suggestion.
<p>Removed $off = $fieldOffset - 1 line in db2 driver, FetchField(). Tx Larry Menard.
<p>Added support for PHP5 objects as Execute() bind parameters using __toString (eg. Simple-XML). Thx Carl-Christian Salvesen.
<p>Rounding in tohtml.inc.php did not work properly. Fixed.
<p>MetaIndexes in postgres fails when fields are deleted then added in again because the attnum has gaps in it. 
See http://sourceforge.net/tracker/index.php?func=detail&aid=1451245&group_id=42718&atid=433976. Fixed.
<p>MetaForeignkeys in mysql and mysqli did not work when fetchMode==ADODB_FETCH_ASSOC used. Fixed.
<p>Reference error in AutoExecute() fixed.
<p>Added macaddr postgres type to MetaType. Maps to 'C'.
<p>Added to _connect() in adodb-ado5.inc.php support for $database and $dataProvider parameters.  Thx Larry Menard.
<p>Added support for sequences in adodb-ado_mssql.inc.php. Thx Larry Menard.
<p>Added ADODB_SESSION_READONLY.
<p>Added session expiryref support to crc32 mode, and in LOB code.
<p>Clear _errorMsg in postgres7 driver, so that ErrorMsg() displays properly when no error occurs.
<p>Added BindDate and BindTimeStamp
<p><a name="4.81"></a><b>4.81 3 May 2006</b>
<p>Fixed variable ref errors in adodb-ado5.inc.php in _query().
<p>Mysqli setcharset fix using method_exists().
<p>The adodb-perf.inc.php CreateLogTable() code now works for user-defined table names.
<p>Error in ibase_blob_open() fixed. See http://phplens.com/lens/lensforum/msgs.php?id=14997
<p><a name="4.80"></a><b>4.80 8 Mar 2006</b>
<p>Added activerecord support.
<p>Added mysql $conn->compat323 = true if you want MySQL 3.23 compat enabled. Fixes GetOne() Select-Limit problems.
<p>Added adodb-xmlschema03.inc.php to support XML Schema version 3 and updated adodb-datadict.htm docs.
<p>Better memory management in Execute. Thx Mike Fedyk.
<p><a name="4.72"></a><b>4.72 21 Feb 2006</b>
<p>Added 'new' DSN parameter for NConnect().
<p>Pager now sanitizes $PHP_SELF to protect against XSS. Thx to James Bercegay and others.
<p>ADOConnection::MetaType changed to setup $rs->connection correctly. 
<p>New native DB2 driver contributed by Larry Menard, Dan Scott, Andy Staudacher, Bharat Mediratta.
<p>The mssql CreateSequence() did not BEGIN TRANSACTION correctly. Fixed. Thx Sean Lee.
<p>The _adodb_countrecs() function in adodb-lib.inc.php has been revised to handle more ORDER BY variations.
<p><a name="4.71"></a><b>4.71 24 Jan 2006</b>
<p>Fixes postgresql security issue related to binary strings. Thx to Andy Staudacher.
<p>Several DSN bugs found:
<p>1. Fix bugs in DSN connections introduced in 4.70 when underscores are found in the DSN. 
<p>2. DSN with _ did not work properly in PHP5 (fine in PHP4). Fixed.
<p>3. Added support for PDO DSN connections in NewADOConnection(), and database parameter in PDO::Connect().
<p>The oci8 datetime flag not correctly implemented in ADORecordSet_array. Fixed.
<p>Added BlobDelete() to postgres, as a counterpoint to UpdateBlobFile().
<p>Fixed GetInsertSQL() to support oci8po.
<p>Fixed qstr() issue with postgresql with \0 in strings.
<p>Fixed some datadict driver loading issues in _adodb_getdriver(). 
<p>Added register shutdown function session_write_close in adodb-session.inc.php for PHP 5 compat. See http://phplens.com/lens/lensforum/msgs.php?id=14200.
<p><a name="4.70"></a><b>4.70 6 Jan 2006</b>
<p>Many fixes from Danila Ulyanov  to ibase, oci8, postgres, mssql, odbc_oracle, odbtp, etc drivers.
<p>Changed usage of binary hint in adodb-session.inc.php for mysql. See 
http://phplens.com/lens/lensforum/msgs.php?id=14160
<p>Fixed invalid variable reference problem in undomq(), adodb-perf.inc.php.
<p>Fixed http://phplens.com/lens/lensforum/msgs.php?id=14254 in adodb-perf.inc.php, _DBParameter() settings of fetchmode was wrong.
<p>Fixed security issues in server.php and tmssql.php discussed by Andreas Sandblad in a Secunia security advisory. Added $ACCEPTIP = 127.0.0.1
and changed suggested root password to something more secure.
<p>Changed pager to close recordset after RenderLayout().
<p><a name="4.68"></a><b>4.68 25 Nov  2005</b>
<p>PHP 5 compat for mysqli. MetaForeignKeys repeated twice and MYSQLI_BINARY_FLAG missing.
<p>PHP 5.1 support for postgresql bind parameters using ? did not work if >= 10 parameters. Fixed. Thx to Stanislav Shramko.
<p>Lots of PDO improvements.
<p>Spelling error fixed in mysql MetaForeignKeys, $associative parameter.
<p><a name="4.67"></a><b>4.67 16 Nov  2005</b>
<p>Postgresql not_null flag not set to false correctly. Thx Cristian MARIN.
<p>We now check in Replace() if key is in fieldArray. Thx Séstien Vanvelthem.
<p>_file_get_contents() function was missing in xmlschema. fixed.
<p>Added week in year support to SQLDate(), using 'W' flag. Thx Spider.
<p>In sqlite metacolumns was repeated twice, causing PHP 5 problems. Fixed.
<p>Made debug output XHTML compliant. 
<p><a name="4.66"></a><b>4.66 28 Sept  2005</b>
<p>ExecuteCursor() in oci8 did not clean up properly on failure. Fixed.
<p>Updated xmlschema.dtd, by "Alec Smecher" asmecher#smecher.bc.ca
<p>Hardened SelectLimit, typecasting nrows and offset to integer.
<p>Fixed misc bugs in AutoExecute() and GetInsertSQL().
<p>Added $conn->database as the property holding the database name. The older $conn->databaseName is retained for backward
compat.
<p>Changed _adodb_backtrace() compat check to use function_exists().
<p>Bug in postgresql MetaIndexes fixed. Thx Kevin Jamieson. 
<p>Improved OffsetDate for MySQL, reducing rounding error.
<p>Metacolumns added to sqlite. Thx Mark Newnham.
<p>PHP 4.4 compat fixes for GetAssoc().
<p>Added postgresql bind support for php 5.1. Thx Cristiano da Cunha Duarte
<p>OffsetDate() fixes for postgresql, typecasting strings to date or timestamp.
<p>DBTimeStamp formats for mssql, odbc_mssql and postgresql made to conform with other db's.
<p>Changed PDO constants from PDO_ to PDO:: to support latest spec.
<p><a name="4.65"></a><b>4.65 22 July  2005</b>
<p>Reverted 'X' in mssql datadict to 'TEXT' to be compat with mssql driver. However now you can 
set $datadict->typeX = 'varchar(4000)' or 'TEXT' or 'CLOB' for mssql and oci8 drivers. 
<p>Added charset support when using DSN for Oracle.
<p>_adodb_getmenu did not use fieldcount() to get number of fields. Fixed.
<p>MetaForeignKeys() for mysql/mysqli contributed by Juan Carlos Gonzalez.
<p>MetaDatabases() now correctly returns an array for mysqli driver. Thx Cristian MARIN.
<p>CompleteTrans(false) did not return false. Fixed. Thx to JMF.
<p>AutoExecute() did not work with Oracle. Fixed. Thx Joséoreira.
<p>MetaType() added to connection object.
<p>More PHP 4.4 reference return fixes. Thx Ryan C Bonham and others.

<p><a name="4.64"></a><b>4.64 20 June 2005</b>
<p>In datadict, if the default field value is set to '', then it is not applied when the field is created. Fixed by Eugenio.
<p>MetaPrimaryKeys for postgres did not work because of true/false change in 4.63. Fixed.
<p>Tested ocifetchstatement in oci8. Rejected at the end.
<p>Added port to dsn handling. Supported in postgres, mysql, mysqli,ldap.
<p>Added  'w' and 'l' to mysqli SQLDate().
<p>Fixed error handling in ldap _connect() to be more consistent. Also added ErrorMsg() handling to ldap.
<p>Added support for union in _adodb_getcount, adodb-lib.inc.php for postgres and oci8.
<p>rs2html() did not work with null dates properly.
<p>PHP 4.4 reference return fixes.

<p><a name="4.63"></a><b>4.63  18 May 2005</b>
<p>Added $nrows<0 check to mysqli's SelectLimit().
<p>Added OptimizeTable() and OptimizeTables() in adodb-perf.inc.php. By Markus Staab.
<p>PostgreSQL inconsistencies fixed. true and false set to TRUE and FALSE, and boolean type in datadict-postgres.inc.php set
to 'L' => 'BOOLEAN'. Thx Kevin Jamieson.
<p>New adodb_session_create_table() function in adodb-session.inc.php. By Markus Staab.
<p>Added null check to UserTimeStamp().
<p>Fixed typo in mysqlt driver in adorecordset. Thx to Andy Staudacher.
<p>GenID() had a bug in the raiseErrorFn handling. Fixed. Thx Marcos Pont.
<p>Datadict name quoting now handles ( ) in index fields correctly - they aren't part of the index field.
<p>Performance monitoring: (1) oci8 Ixora checks moved down; (2) expensive sql changed so that only those sql with 
count(*)>1 are shown; (3) changed sql1 field to a length+crc32 checksum - this breaks backward compat.
<p>We remap firebird15 to firebird in data dictionary.

<p><a name="4.62"></a><b>4.62  2 Apr 2005</b>
<p>Added 'w' (dow as 0-6 or 1-7) and 'l' (dow as string) for SQLDate for oci8, postgres and mysql.
<p>Rolled back MetaType() changes for mysqli done in prev version.
<p>Datadict change by chris, cblin#tennaxia.com data mappings from:
<pre>
oci8:  X->varchar(4000) XL->CLOB
mssql: X->XL->TEXT
mysql: X->XL->LONGTEXT
fbird: X->XL->varchar(4000)
</pre>
<p>to:
<pre>
oci8:  X->varchar(4000) XL->CLOB
mssql: X->VARCHAR(4000) XL->TEXT
mysql: X->TEXT          XL->LONGTEXT
fbird: X->VARCHAR(4000) XL->VARCHAR(32000)
</pre>
<p>Added $connection->disableBlobs to postgresql to improve performance when no bytea is used (2-5% improvement).
<p>Removed all HTTP_* vars.
<p>Added $rs->tableName to be set before calling AutoExecute().
<p>Alex Rootoff rootoff#pisem.net contributed ukrainian language file.
<p>Added new mysql_option() support using $conn->optionFlags array.
<p>Added support for ldap_set_option() using the $LDAP_CONNECT_OPTIONS global variable. Contributed by Josh Eldridge.
<p>Added LDAP_* constant definitions to ldap.
<p>Added support for boolean bind variables. We use $conn->false and $conn->true to hold values to set false/true to.
<p>We now do not close the session connection in adodb-session.inc.php as other objects could be using this connection.
<p>We now strip off \0 at end of Ixora SQL strings in $perf->tohtml() for oci8.
<p><a name="4.61"></a><b>4.61 23 Feb 2005</b>
<p>MySQLi added support for mysqli_connect_errno() and mysqli_connect_error().
<p>Massive improvements to alpha PDO driver.
<p>Quote string bind parameters logged by performance monitor for easy type checking. Thx Jason Judge.
<p>Added support for $role when connecting with Interbase/firebird.
<p>Added support for enum recognition in MetaColumns() mysql and mysqli. Thx Amedeo Petrella.
<p>The sybase_ase driver contributed by Interakt Online. Thx Cristian Marin cristic#interaktonline.com.
<p>Removed not_null, has_default, and default_value from ADOFieldObject.
<p>Sessions code, fixed quoting of keys when handling LOBs in session write() function.
<p>Sessions code, added adodb_session_regenerate_id(), to reduce risk of session hijacking by changing session cookie dynamically. Thx Joe Li.
<p>Perf monitor, polling for CPU did not work for PHP 4.3.10 and 5.0.0-5.0.3 due to PHP bugs, so we special case these versions.
<p>Postgresql, UpdateBlob() added code to handle type==CLOB.
<p><a name="4.60"></a><b>4.60 24 Jan 2005</b>
<p>Implemented PEAR DB's autoExecute(). Simplified design because I don't like using constants when
strings work fine.
<p>_rs2serialize will now update $rs->sql and $rs->oldProvider.
<p>Added autoExecute().
<p>Added support for postgres8 driver. Currently just remapped to postgres7 driver.
<p>Changed oci8 _query(), so that OCIBindByName() sets the length to -1 if element size is > 4000. This provides better support
for LONGs.
<p>Added SetDateLocale() support for netherlands (Nl).
<p>Spelling error in pivot code ($iff should be $iif).
</p><p>mysql insert_id() did not work with mysql 3.x. Fixed.
</p><p>"\r\n" not converted to spaces correctly in exporting data. Fixed.
</p><p>_nconnect() in mysqli did not return value correctly. Fixed.
</p><p>Arne Eckmann contributed danish language file.
</p><p>Added clone() support to FetchObject() for PHP5.<br>
</p>
<p>Removed SQL_CUR_USE_ODBC from odbc_mssql.<br>
</p>
<p><a name="4.55"></a><b>4.55 5 Jan 2005</b>
</p><p>Found bug in Execute() with bind params for db's that do not support binding natively.
</p><p>DropSequence() now correctly uses default parameter.
</p><p>Now Execute() ignores locale for floats, so 1.23 is NEVER converted to 1,23.
</p><p>SetFetchMode() not properly saved in adodb-perf, suspicious sql and expensive sql. Fixed.
</p><p>Added INET to postgresql metatypes. Thx motzel.
</p><p>Allow oracle hints to work when counting with _adodb_getcount in adodb-lib.inc.php. Thx Chris Wrye.
</p><p>Changed mysql insert_id() to use SELECT LAST_INSERT_ID().
</p><p>If alter col in datadict does not modify col type/size of actual
col, then it is removed from alter col code. By Mark Newham. Not
perfect as MetaType() !== ActualType().
</p><p>Added handling of view fields in metacolumns() for postgresql. Thx Renato De Giovanni.
</p><p>Added to informix MetaPrimaryKeys and MetaColumns fixes for null bit. Thx to Cecilio Albero.
</p><p>Removed obsolete connection_timeout() from perf code.
</p><p>Added support for arrayClass in adodb-csv.inc.php.
</p><p>RSFilter now accepts methods of the form $array($obj, 'methodname'). Thx to blake#near-time.com.
</p><p>Changed CacheFlush to $cmd = 'rm -rf '.$ADODB_CACHE_DIR.'/[0-9a-f][0-9a-f]/'; 
</p><p>For better cursor concurrency, added code to free ref cursors in
oci8 when $rs-&gt;Close() is called. Note that CLose() is called
internally by the Get* functions too.
</p><p>Added IIF support for access when pivoting.  Thx Volodia Krupach.
</p><p>Added mssql datadict support for timestamp. Thx Alexios.
</p><p>Informix pager fix. By Mario Ramirez.
</p><p>ADODB_TABLE_REGEX now includes ':'. By Mario Ramirez.
</p><p>Mark Newnham contributed MetaIndexes for oci8 and db2.
</p><p><a name="4.54"></a><b>4.54 5 Nov 2004</b>
</p><p>
Now you can set $db-&gt;charSet = ?? before doing a Connect() in oci8.
</p><p>
Added adodbFetchMode to sqlite.
</p><p>
Perf code, added a string typecast to substr in adodb_log_sql().
</p><p>
Postgres: Changed BlobDecode() to use po_loread, added new $maxblobsize parameter, and now it returns the blob instead
of sending it to stdout - make sure to mention that as a compat warning.
Also added $db-&gt;IsOID($oid) function; uses a heuristic, not guaranteed to work 100%.
</p><p>
Contributed arabic language file by "El-Shamaa, Khaled" k.el-shamaa#cgiar.org
</p><p>
PHP5 exceptions did not handle @ protocol properly. Fixed.
</p><p>
Added ifnull handling for postgresql (using coalesce).
</p><p>
Added  metatables() support for Postgresql 8.0 (no longer uses pg_% dictionary tables).
</p><p>
Improved Sybase ErrorMsg() function. By Gaetano Giunta.
</p><p>
Improved oci8 SelectLimit() to use Prepare(). By Cristiano Duarte.
</p><p>
Type-cast $row parameter in ifx_fetch_row() to int. Thx stefan bodgan.
</p><p>Ralf becker contributed improvements in postgresql, sapdb, mysql data dictionary handling:<br>
- MySql and Postgres MetaType was reporting every int column which was 
part of a primary key and unique as serial<br>
- Postgres was not reporting the scale of decimal types<br>
- MaxDB was padding the defaults of none-string types with spaces<br>
- MySql now correctly converts enum columns to varchar
</p><p>
Ralf also changed Postgresql datadict:<br>
- you cant add NOT NULL columns in postgres in one go, they need to be 
added as NULL and then altered to NOT NULL<br>
- AlterColumnSQL could not change a varchar column with numbers into an 
integer column, postgres need an explicit conversation<br>
- a re-created sequence was not set to the correct value, if the name 
was the old name (no implicit sequence), now always the new name of the 
implicit sequence is used<br>
</p><p>Sergio Strampelli added extra $intoken check to Lens_ParseArgs() in datadict code.
</p><p><a name="4.53"></a><b>4.53 28 Sept 2004</b>
</p><p>FetchMode cached in recordset is sometimes mapped to native db fetchMode. Normally this does not matter,
but when using cached recordsets, we need to switch back to using adodb fetchmode.  So we cache this
in $rs-&gt;adodbFetchMode if it differs from the db's fetchMode.
</p><p>For informix we now set canSeek = false driver because stefan bodgan tells me that seeking doesn't work. 
</p><p>SetDateLocale() never worked till now ;-) Thx david#tomato.it
</p><p>Set $_bindInputArray = true in sapdb driver. Required for clob support.
</p><p>Fixed some PEAR::DB emulation issues with isError() and isWarning. Thx to Gert-Rainer Bitterlich.
</p><p>Empty() used in getupdatesql without strlen() check. Fixed.</p>
<p>Added unsigned detection to mysql and mysqli drivers. Thx to dan cech.
</p><p>Added hungarian language file. Thx to Hal&aacute;szv&aacute;ri G&aacute;bor.
</p><p>Improved fieldname-type formatting of datadict SQL generated (adding $widespacing parameter to _GenField).
</p><p>Datadict oci8 DROP CONSTRAINTS misspelt. Fixed. Thx Mark Newnham.
</p><p>Changed odbtp to dynamically change databaseType based on connection, eg. from 'odbtp' to 'odbtp_mssql' when connecting
to mssql database.
</p><p>In datadict, MySQL I4 was wrongly mapped to MEDIUMINT, which is actually I3. Fixed.
</p><p>Fixed mysqli MetaType() recognition. Mysqli returns numeric types unlike mysql extension. Thx Francesco Riosa.
</p><p>VFP odbc driver curmode set wrongly, causing problems with memo fields. Fixed.
</p><p>Odbc driver did not recognize odbc version 2 driver date types properly. Fixed. Thx Bostjan.
</p><p>ChangeTableSQL() fixes to datadict-db2.inc.php by Mark Newnham.
</p><p>Perf monitoring with odbc improved. Now we try in perf code to manually set the sysTimeStamp using date() if sysTimeStamp
is empty.
</p><p>All ADO errors are thrown as exceptions in PHP5. 
So we added exception handling to ado in PHP5 by creating new adodb-ado5.inc.php driver.
</p><p>Added IsConnected(). Returns true if connection object connected. By Luca.Gioppo.
</p><p>"Ralf Becker"
RalfBecker#digitalROCK.de contributed new sapdb data-dictionary driver
and a large patch that implements field and table renaming for oracle,
mssql, postgresql, mysql and sapdb. See the new RenameTableSQL() and
RenameColumnSQL() functions.
</p><p>We now check ExecuteCursor to see if PrepareSP was initially called.
</p><p>Changed oci8 datadict to use MODIFY for $dd-&gt;alterCol. Thx Mark Newnham.
</p><p><a name="4.52"></a><b>4.52  10 Aug 2004</b>
</p><p>Bug found in Replace() when performance logging enabled, introduced in ADOdb 4.50. Fixed.
</p><p>Replace() checks update stmt. If update stmt fails, we now return immediately. Thx to alex.
</p><p>Added support for $ADODB_FORCE_TYPE in GetUpdateSQL/GetInsertSQL. Thx to niko.
</p><p>Added ADODB_ASSOC_CASE support to postgres/postgres7 driver.
</p><p>Support for DECLARE stmt in oci8. Thx Lochbrunner.
</p><p><a name="4.51"></a><b>4.51  29 July  2004</b>
</p><p>Added adodb-xmlschema 1.0.2. Thx dan and richard.
</p><p>Added new adorecordset_ext_* classes. If ADOdb extension installed for mysql, mysqlt and oci8 
(but not oci8po),  we use the superfast ADOdb extension code for movenext.
</p><p>Added schema support to mssql and odbc_mssql MetaPrimaryKeys().
</p><p>Patched MSSQL driver to support PHP NULL and Boolean values 
while binding the input array parameters in the _query() function. By Stephen Farmer.
</p><p>Added support for clob's for mssql,  UpdateBlob(). Thx to gfran#directa.com.br
</p><p>Added normalize support for postgresql (true=lowercase table name, or false=case-sensitive table names) 
to MetaColumns($table, $normalize=true).
</p><p>PHP5 variant dates in ADO not working. Fixed in adodb-ado.inc.php.
</p><p>Constant ADODB_FORCE_NULLS was not working properly for many releases (for GetUpdateSQL). Fixed. 
Also GetUpdateSQL strips off ORDER BY now - thx Elieser Le&atilde;o.
</p><p>Perf Monitor for oci8 now dynamically highlights optimizer_* params if too high/low.
</p><p>Added dsn support to NewADOConnection/ADONewConnection.
</p><p>Fixed out of page bounds bug in _adodb_pageexecute_all_rows() Thx to "Sergio Strampelli" sergio#rir.it
</p><p>Speedup of movenext for mysql and oci8 drivers.
</p><p>Moved debugging code _adodb_debug_execute() to adodb-lib.inc.php.
</p><p>Fixed postgresql bytea detection bug. See http://phplens.com/lens/lensforum/msgs.php?id=9849.
</p><p>Fixed ibase datetimestamp typo in PHP5. Thx stefan.
</p><p>Removed whitespace at end of odbtp drivers.
</p><p>Added db2 metaprimarykeys fix.
</p><p>Optimizations to MoveNext() for mysql and oci8. Misc speedups to Get* functions.
</p><p><a name="4.50"></a><b>4.50  6 July  2004</b>
</p><p>Bumped it to 4.50 to avoid confusion with PHP 4.3.x series.
</p><p>Added db2 metatables and metacolumns extensions.
</p><p>Added alpha PDO driver. Very buggy, only works with odbc.
</p><p>Tested mysqli. Set poorAffectedRows = true. Cleaned up movenext() and _fetch().
</p><p>PageExecute does not work properly with php5 (return val not a variable). Reported Dmytro Sychevsky sych#php.com.ua.  Fixed.
</p><p>MetaTables() for mysql, $showschema parameter was not backward compatible with older versions of adodb. Fixed.
</p><p>Changed mysql GetOne() to work with mysql 3.23 when using with non-select stmts (e.g. SHOW TABLES).
</p><p>Changed TRIG_ prefix to a variable in datadict-oci8.inc.php. Thx to Luca.Gioppo#csi.it.
</p><p>New to adodb-time code. We allow you to define your own daylights savings function, 
adodb_daylight_sv for pre-1970 dates. If the function is defined 
(somewhere in an include), then you can correct 
for daylights savings. See http://phplens.com/phpeverywhere/node/view/16#daylightsavings
for more info.
</p><p>New sqlitepo driver. This is because assoc mode does not work like other drivers in sqlite.
   Namely, when selecting (joining) multiple tables, in assoc mode the table
      names are included in the assoc keys in the "sqlite" driver.
      In "sqlitepo" driver, the table names are stripped from the returned column names. 
      When this results in a conflict,  the first field get preference.
    Contributed by Herman Kuiper  herman#ozuzo.net  
</p><p>Added $forcenull parameter to GetInsertSQL/GetUpdateSQL. Idea by Marco Aurelio Silva.
</p><p>More XHTML changes for GetMenu. By Jeremy Evans.
</p><p>Fixes some ibase date issues. Thx to stefan bogdan.
</p><p>Improvements to mysqli driver to support $ADODB_COUNTRECS.
</p><p>Fixed adodb-csvlib.inc.php problem when reading stream from socket. We need to poll stream continiously.
</p><p><a name="4.23"></a><b>4.23  16 June   2004</b>
</p><p>
New interbase/firebird fixes thx to Lester Caine.
Driver fixes a problem with getting field names in the result array, and 
corrects a couple of data conversions. Also we default to dialect3 for firebird.
Also ibase sysDate property was wrong. Changed to cast as timestamp.
</p><p>
The datadict driver is set up to give quoted tables and fields as this 
was the only way round reserved words being used as field names in 
TikiWiki. TikiPro is tidying that up, and I hope to be able to produce a 
build of THAT which uses what I consider proper UPPERCASE field and 
table names. The conversion of TikiWiki to ADOdb helped in that, but 
until the database is completely tidied up in TikiPro ...
</p><p>Modified _gencachename() to include fetchmode in name hash.
This means you should clear your cache directory after installing this release as the 
cache name algorithm has changed.
</p><p>Now Cache* functions work in safe
mode, because we do not create sub-directories in the $ADODB_CACHE_DIR
in safe mode. In non-safe mode we still create sub-directories. Done by
modifying _gencachename().
</p><p>Added $gmt parameter (true/false)
to UserDate and UserTimeStamp in connection class, to force conversion
of input (in local time) to be converted to UTC/GMT.
</p><p>Mssql datadict did not support INT types properly (no size param allowed). 
Added _GetSize() to datadict-mssql.inc.php.
</p><p>For borland_ibase, BeginTrans(), changed:<br>
</p><pre>   $this-&gt;_transactionID = $this-&gt;_connectionID;</pre>
to<br>
<pre>   $this-&gt;_transactionID = ibase_trans($this-&gt;ibasetrans, $this-&gt;_connectionID);</pre>
        
<p>Fixed typo in mysqi_field_seek(). Thx to Sh4dow (sh4dow#php.pl).
</p><p>LogSQL did not work with Firebird/Interbase. Fixed.
</p><p>Postgres: made errorno() handling more consistent. Thx to Michael Jahn, Michael.Jahn#mailbox.tu-dresden.de.
</p><p>Added informix patch to better support metatables, metacolumns by "Cecilio Albero" c-albero#eos-i.com
</p><p>Cyril Malevanov contributed patch to oci8 to support passing of LOB parameters:
</p><pre>   $text = 'test test test';<br>   $sql = "declare rs clob; begin :rs := lobinout(:sa0); end;";<br>    $stmt = $conn -&gt; PrepareSP($sql);<br>    $conn -&gt; InParameter($stmt,$text,'sa0', -1, OCI_B_CLOB);<br> $rs = '';<br>   $conn -&gt; OutParameter($stmt,$rs,'rs', -1, OCI_B_CLOB);<br>   $conn -&gt; Execute($stmt);<br> echo "return = ".$rs."&lt;br&gt;";<br></pre>
As he says, the LOBs limitations are:
<pre> - use OCINewDescriptor before binding<br> - if Param is IN, uses save() before each execute. This is done automatically for you.<br> - if Param is OUT, uses load() after each execute. This is done automatically for you.<br> - when we bind $var as LOB, we create new descriptor and return it as a<br>   Bind Result, so if we want to use OUT parameters, we have to store<br>   somewhere &amp;$var to load() data from LOB to it.<br> - IN OUT params are not working now (should not be a big problem to fix it)<br> - now mass binding not working too (I've wrote about it before)<br></pre>
<p>Simplified Connect() and PConnect() error handling.
</p><p>When extension not loaded, Connect() and PConnect() will return null. On connect error, the fns will return false.
</p><p>CacheGetArray() added to code.
</p><p>Added Init() to adorecordset_empty().
</p><p>Changed postgres64 driver, MetaColumns() to not strip off quotes in default value if :: detected (type-casting of default).
</p><p>Added test: if (!defined('ADODB_DIR')) die(). Useful to prevent hackers from detecting file paths.
</p><p>Changed metaTablesSQL to ignore Postgres 7.4 information schemas (sql_*).
</p><p>New polish language file by  Grzegorz Pacan
</p><p>Added support for UNION in _adodb_getcount().
</p><p>Added security check for ADODB_DIR to limit path disclosure issues. Requested by postnuke team.
</p><p>Added better error message support to oracle driver. Thx to Gaetano Giunta.
</p><p>Added showSchema support to mysql.
</p><p>Bind in oci8 did not handle $name=false properly. Fixed.
</p><p>If extension not loaded, Connect(), PConnect(), NConnect() will return null.
</p><p><b>4.22  15 Apr   2004</b></p>
<p>Fixed session bug when quoting compressed/encrypted data in Replace().
<p>Netezza Driver and LDAP drivers contributed by Josh Eldridge.
<p>GetMenu now uses rtrim() on values instead of trim().
<p>Changed MetaColumnNames to return an associative array, keys being the field names in uppercase.
<p>Suggested fix to adodb-ado.inc.php affected_rows to support PHP5 variants. Thx to Alexios Fakos.
<p>Contributed bulgarian language file by Valentin Sheiretsky valio#valio.eu.org.
<p>Contributed romanian language file by stefan bogdan.
<p>GetInsertSQL now checks for table name (string) in $rs, and will create a recordset for that
table automatically. Contributed by Walt Boring. Also added OCI_B_BLOB in bind on Walt's request - hope
it doesn't break anything :-)
<p>Some minor postgres speedups in _initrs().
<p> ChangeTableSQL checks now if MetaColumns returns empty. Thx Jason Judge.
<p>Added ADOConnection::Time(), returns current database time in unix timestamp format, or false.
<p><b>4.21 20 Mar 2004</b>
<p>We no longer in SelectLimit for VFP driver add SELECT TOP X unless an ORDER BY exists.
<p>Pim Koeman contributed dutch language file adodb-nl.inc.php.
<p>Rick Hickerson added CLOB support to db2 datadict.
<p>Added odbtp driver. Thx to "stefan bogdan" sbogdan#rsb.ro.
<p>Changed PrepareSP() 2nd parameter, $cursor, to default to true (formerly false). Fixes oci8 backward
compat problems with OUT params.
<p>Fixed month calculation error in adodb-time.inc.php. 2102-June-01 appeared as 2102-May-32.
<p>Updated PHP5 RC1 iterator support. API changed, hasMore() renamed to valid().
<p>Changed internal format of serialized cache recordsets. As we store a version number, this should be
backward compatible.
<p>Error handling when driver file not found was flawed in ADOLoadCode(). Fixed.
<p><b>4.20 27 Feb 2004</b>
<p>Updated to AXMLS 1.01.
<p>MetaForeignKeys for postgres7 modified by Edward Jaramilla, works on pg 7.4.
<p>Now numbers accepts function calls or sequences for GetInsertSQL/GetUpdateSQL numeric fields.
<p>Changed quotes of 'delete from $perf_table' to "". Thx Kehui (webmaster#kehui.net)
<p>Added ServerInfo() for ifx, and putenv trim fix. Thx Fernando Ortiz.
<p>Added addq(), which is analogous to addslashes().
<p>Tested with php5b4. Fix some php5 compat problems with exceptions and sybase.
<P>Carl-Christian Salvesen added patch to mssql _query to support binds greater than 4000 chars.
<p>Mike suggested patch to PHP5 exception handler. $errno must be numeric.
<p>Added double quotes (") to ADODB_TABLE_REGEX.
<p>For oci8, Prepare(...,$cursor), $cursor's meaning was accidentally inverted in 4.11. This causes problems with ExecuteCursor() too, which calls Prepare() internally. Thx to William Lovaton.
<p>Now dateHasTime property in connection object renamed to datetime for consistency. This could break bc.
<p>Csongor Halmai reports that db2 SelectLimit with input array is not working. Fixed..
<p><b>4.11 27 Jan 2004</b>
<p>Csongor Halmai reports db2 binding not working. Reverted back to emulated binding.
<p>Dan Cech modifies datadict code. Adds support for DropIndex. Minor cleanups.
<p>Table misspelt in perf-oci8.inc.php. Changed v$conn_cache_advice to v$db_cache_advice. Reported by Steve W.
<p>UserTimeStamp and DBTimeStamp did not handle YYYYMMDDHHMMSS format properly. Reported by Mike Muir. Fixed.
<p>Changed oci8 Prepare(). Does not auto-allocate OCINewCursor automatically, unless 2nd param is set to true.
This will break backward compat, if Prepare/Execute is used instead of ExecuteCursor. Reported by Chris Jones.
<p>Added InParameter() and OutParameter(). Wrapper functions to Parameter(), but nicer because they
are self-documenting.
<p>Added 'R' handling in ActualType() to datadict-mysql.inc.php
<p>Added ADOConnection::SerializableRS($rs). Returns a recordset that can be serialized in a session.
<p>Added "Run SQL" to performance UI().
<p>Misc spelling corrections in adodb-mysqli.inc.php, adodb-oci8.inc.php and datadict-oci8.inc.php, from Heinz Hombergs.
<p>MetaIndexes() for ibase contributed by Heinz Hombergs.
<p><b>4.10 12 Jan 2004</b>
<p>Dan Cech contributed extensive changes to data dictionary to support name quoting (with `), and drop table/index.
<p>Informix added cursorType property. Default remains IFX_SCROLL, but you can change to 0 (non-scrollable cursor) for performance.
<p>Added ADODB_View_PrimaryKeys() for returning view primary keys to MetaPrimaryKeys().
<p>Simplified chinese file, adodb-cn.inc.php from cysoft.
<p>Added check for ctype_alnum in adodb-datadict.inc.php. Thx to Jason Judge.
<p>Added connection parameter to ibase Prepare(). Fix by Daniel Hassan.
<p>Added nameQuote for quoting identifiers and names to connection obj. Requested by Jason Judge. Also the
data dictionary parser now detects `field name` and generates column names with spaces correctly.
<p>BOOL type not recognised correctly as L. Fixed.
<p>Fixed paths in ADODB_DIR for session files, and back-ported it to 4.05 (15 Dec 2003)
<p>Added Schema to postgresql MetaTables. Thx to col#gear.hu
<p>Empty postgresql recordsets that had blob fields did not set EOF properly. Fixed.
<p>CacheSelectLimit internal parameters to SelectLimit were wrong. Thx to Nio.
<p>Modified adodb_pr() and adodb_backtrace() to support command-line usage (eg. no html).
<p>Fixed some fr and it lang errors. Thx to Gaetano G.
<p>Added contrib directory, with adodb rs to xmlrpc convertor by Gaetano G.
<p>Fixed array recordset bugs when _skiprow1 is true. Thx to Gaetano G.
<p>Fixed pivot table code when count is false.
<p>

<p><b>4.05 13 Dec 2003 </b>
<p>Added MetaIndexes - thx to Dan Cech.
<p>Rewritten session code by Ross Smith. Moved code to adodb/session directory.
<p>Added function exists check on connecting to most drivers, so we don't crash with the unknown function error.
<p>Smart Transactions failed with GenID() when it no seq table has been created because the sql
	statement fails. Fix by Mark Newnham.
<p>Added $db->length, which holds name of function that returns strlen.
<p>Fixed error handling for bad driver in ADONewConnection - passed too few params to error-handler.
<p>Datadict did not handle types like 16.0 properly in _GetSize. Fixed.
<p>Oci8 driver SelectLimit() bug &= instead of =& used. Thx to Swen Thümmler.
<p>Jesse Mullan suggested not flushing outp when output buffering enabled. Due to Apache 2.0 bug. Added.
<p>MetaTables/MetaColumns return ref bug with PHP5 fixed in adodb-datadict.inc.php.
<p>New mysqli driver contributed by Arjen de Rijke. Based on adodb 3.40 driver.
Then jlim added BeginTrans, CommitTrans, RollbackTrans, IfNull, SQLDate. Also fixed return ref bug.
<p>$ADODB_FLUSH added, if true then force flush in debugging outp. Default is false.  In earlier
versions, outp defaulted to flush, which is not compat with apache 2.0.
<p>Mysql driver's GenID() function did not work when when sql logging is on. Fixed.
<p>$ADODB_SESSION_TBL not declared as global var. Not available if adodb-session.inc.php included in function. Fixed.
<p>The input array not passed to Execute() in _adodb_getcount(). Fixed.
<p><b>4.04 13 Nov 2003 </b>
<p>Switched back to foreach - faster than list-each.
<p>Fixed bug in ado driver - wiping out $this->fields with date fields.
<p>Performance Monitor, View SQL, Explain Plan did not work if strlen($SQL)>max($_GET length). Fixed.
<p>Performance monitor, oci8 driver added memory sort ratio.
<p>Added random property, returns SQL to generate a floating point number between 0 and 1;
<p><b>4.03 6 Nov 2003 </b>
<p>The path to adodb-php4.inc.php and adodb-iterators.inc.php was not setup properly.
<p>Patched SQLDate in interbase to support hours/mins/secs. Thx to ari kuorikoski.
<p>Force autorollback for pgsql persistent connections - 
apparently pgsql did not autorollback properly before 4.3.4. See http://bugs.php.net/bug.php?id=25404
<p><b>4.02 5 Nov 2003 </b>
<p>Some errors in adodb_error_pg() fixed. Thx to Styve.
<p>Spurious Insert_ID() error was generated by LogSQL(). Fixed.
<p>Insert_ID was interfering with Affected_Rows() and Replace()  when LogSQL() enabled. Fixed.
<p>More foreach loops optimized with list/each.
<p>Null dates not handled properly in ADO driver (it becomes 31 Dec 1969!).
<p>Heinz Hombergs contributed patches for mysql MetaColumns - adding scale, made
interbase MetaColumns work with firebird/interbase, and added lang/adodb-de.inc.php.
<p>Added INFORMIXSERVER environment variable.
<p>Added $ADODB_ANSI_PADDING_OFF for interbase/firebird.
<p>PHP 5 beta 2 compat check. Foreach (Iterator) support. Exceptions support.
<p><b>4.01 23 Oct 2003 </b>
<p>Fixed bug in rs2html(), tohtml.inc.php, that generated blank table cells.
<p>Fixed insert_id() incorrectly generated when logsql() enabled.
<p>Modified PostgreSQL _fixblobs to use list/each instead of foreach.
<p>Informix ErrorNo() implemented correctly.
<p>Modified several places to use list/each, including GetRowAssoc().
<p>Added UserTimeStamp() to connection class.
<p>Added $ADODB_ANSI_PADDING_OFF for oci8po.
<p><b>4.00 20 Oct 2003 </b>
<p>Upgraded adodb-xmlschema to 1 Oct 2003 snapshot.
<p>Fix to rs2html warning message. Thx to Filo.
<p>Fix for odbc_mssql/mssql SQLDate(), hours was wrong.
<p>Added MetaColumns and MetaPrimaryKeys for sybase. Thx to Chris Phillipson.
<p>Added autoquoting to datadict for MySQL and PostgreSQL. Suggestion by Karsten Dambekalns  
<p><b>3.94 11 Oct 2003 </b>
<p>Create trigger in datadict-oci8.inc.php did not work, because all cr/lf's must be removed. 
<p>ErrorMsg()/ErrorNo() did not work for many databases when logging enabled. Fixed.
<p>Removed global variable $ADODB_LOGSQL as it does not work properly with multiple connections.
<p>Added SQLDate support for sybase. Thx to Chris Phillipson
<p>Postgresql checking of pgsql resultset resource was incorrect. Fix by Bharat Mediratta bharat#menalto.com.
Same patch applied to  _insertid and _affectedrows for adodb-postgres64.inc.php.
<p>Added support for NConnect for postgresql.
<p>Added Sybase data dict support. Thx to Chris Phillipson  
<p>Extensive improvements in $perf->UI(), eg. Explain now opens in new window, we show scripts
which call sql, etc.
<p>Perf Monitor UI works with magic quotes enabled.
<p>rsPrefix was declared twice. Removed.
<p>Oci8 stored procedure support, eg. "begin func(); end;" was incorrect in _query. Fixed.
<p>Tiraboschi Massimiliano contributed italian language file.
<p>Fernando Ortiz, fortiz#lacorona.com.mx, contributed informix performance monitor.
<p>Added _varchar (varchar arrays) support for postgresql. Reported by PREVOT Stéphane.
<p><b>3.92 22 Sept 2003</b> 
<p>Added GetAssoc and CacheGetAssoc to connection object.
<p>Removed TextMax and CharMax functions from adodb.inc.php. 
<p>HasFailedTrans() returned false when trans failed. Fixed. 
<p>Moved perf driver classes into adodb/perf/*.php. 
<p>Misc improvements to performance monitoring, including UI(). 
<p>RETVAL in mssql Parameter(), we do not append @ now. 
<p>Added Param($name) to connection class, returns '?' or ":$name", for defining 
  bind parameters portably. 
<p>LogSQL traps affected_rows() and saves its value properly now. Also fixed oci8 
  _stmt and _affectedrows() bugs. 
<p>Session code timestamp check for oci8 works now. Formerly default NLS_DATE_FORMAT 
  stripped off time portion. Thx to Tony Blair (tonanbarbarian#hotmail.com). Also 
  added new $conn->datetime field to oci8, controls whether MetaType() returns 
  'D' ($this->datetime==false) or 'T' ($this->datetime == true) for DATE type. 
<p>Fixed bugs in adodb-cryptsession.inc.php and adodb-session-clob.inc.php. 
<p>Fixed misc bugs in adodb_key_exists, GetInsertSQL() and GetUpdateSQL(). 
<p>Tuned include_once handling to reduce file-system checking overhead. 
<p><b>3.91 9 Sept 2003</b> 
<p>Only released to InterAkt 
<p>Added LogSQL() for sql logging and $ADODB_NEWCONNECTION to override factory 
  for driver instantiation. 
<p>Added IfNull($field,$ifNull) function, thx to johnwilk#juno.com 
<p>Added portable substr support. 
<p>Now rs2html() has new parameter, $echo. Set to false to return $html instead 
  of echoing it. 
<p><b>3.90 5 Sept 2003</b> 
<p>First beta of performance monitoring released. 
<p>MySQL supports MetaTable() masking. 
<p>Fixed key_exists() bug in adodb-lib.inc.php 
<p>Added sp_executesql Prepare() support to mssql. 
<p>Added bind support to db2. 
<p>Added swedish language file - Christian Tiberg" christian#commsoft.nu 
<p>Bug in drop index for mssql data dict fixed. Thx to Gert-Rainer Bitterlich. 
<p>Left join setting for oci8 was wrong. Thx to johnwilk#juno.com 
<p><b>3.80 27 Aug 2003</b> 
<p>Patch for PHP 4.3.3 cached recordset csv2rs() fread loop incompatibility. 
<p>Added matching mask for MetaTables. Only for oci8, mssql and postgres currently. 
<p>Rewrite of "oracle" driver connection code, merging with "oci8", by Gaetano. 
<p>Added better debugging for Smart Transactions. 
<p>Postgres DBTimeStamp() was wrongly using TO_DATE. Changed to TO_TIMESTAMP. 
<p>ADODB_FETCH_CASE check pushed to ADONewConnection to allow people to define 
  it after including adodb.inc.php. 
<p>Added portugese (brazilian) to languages. Thx to "Levi Fukumori". 
<p>Removed arg3 parameter from Execute/SelectLimit/Cache* functions. 
<p>Execute() now accepts 2-d array as $inputarray. Also changed docs of fnExecute() 
  to note change in sql query counting with 2-d arrays. 
<p>Added MONEY to MetaType in PostgreSQL. 
<p>Added more debugging output to CacheFlush(). 
<p><b>3.72 9 Aug 2003</b> 
<p>Added qmagic($str), which is a qstr($str) that auto-checks for magic quotes 
  and does the right thing... 
<p>Fixed CacheFlush() bug - Thx to martin#gmx.de 
<p>Walt Boring contributed MetaForeignKeys for postgres7. 
<p>_fetch() called _BlobDecode() wrongly in interbase. Fixed. 
<p>adodb_time bug fixed with dates after 2038 fixed by Jason Pell. http://phplens.com/lens/lensforum/msgs.php?id=6980 
<p><b>3.71 4 Aug 2003</b> 
<p>The oci8 driver, MetaPrimaryKeys() did not check the owner correctly when $owner 
  == false. 
<p>Russian language file contributed by "Cyrill Malevanov" cyrill#malevanov.spb.ru. 
<p>Spanish language file contributed by "Horacio Degiorgi" horaciod#codigophp.com. 
<p>Error handling in oci8 bugfix - if there was an error in Execute(), then when 
  calling ErrorNo() and/or ErrorMsg(), the 1st call would return the error, but 
  the 2nd call would return no error. 
<p>Error handling in odbc bugfix. ODBC would always return the last error, even 
  if it happened 5 queries ago. Now we reset the errormsg to '' and errorno to 
  0 everytime before CacheExecute() and Execute(). 
<p><b>3.70 29 July 2003</b> 
<p>Added new SQLite driver. Tested on PHP 4.3 and PHP 5. 
<p>Added limited "sapdb" driver support - mainly date support. 
<p>The oci8 driver did not identify NUMBER with no defined precision correctly. 
<p>Added ADODB_FORCE_NULLS, if set, then PHP nulls are converted to SQL nulls 
  in GetInsertSQL/GetUpdateSQL. 
<p>DBDate() and DBTimeStamp() format for postgresql had problems. Fixed. 
<p>Added tableoptions to ChangeTableSQL(). Thx to Mike Benoit. 
<p>Added charset support to postgresql. Thx to Julian Tarkhanov. 
<p>Changed OS check for MS-Windows to prevent confusion with darWIN (MacOS) 
<p>Timestamp format for db2 was wrong. Changed to yyyy-mm-dd-hh.mm.ss.nnnnnn. 
<p>adodb-cryptsession.php includes wrong. Fixed. 
<p>Added MetaForeignKeys(). Supported by mssql, odbc_mssql and oci8. 
<p>Fixed some oci8 MetaColumns/MetaPrimaryKeys bugs. Thx to Walt Boring. 
<p>adodb_getcount() did not init qryRecs to 0. Missing "WHERE" clause checking 
  in GetUpdateSQL fixed. Thx to Sebastiaan van Stijn. 
<p>Added support for unicamente 'VIEWS' and "TABLES" in MetaTables. From Walt Boring. 
<p>Upgraded to adodb-xmlschema.inc.php 0.0.2. 
<p>NConnect for mysql now returns value. Thx to Dennis Verspuij. 
<p>ADODB_FETCH_BOTH support added to interbase/firebird. 
<p>Czech language file contributed by Kamil Jakubovic jake#host.sk. 
<p>PostgreSQL BlobDecode did not use _connectionID properly. Thx to Juraj Chlebec. 
<p>Added some new initialization stuff for Informix. Thx to "Andrea Pinnisi" pinnisi#sysnet.it 
<p>ADODB_ASSOC_CASE constant wrong in sybase _fetch(). Fixed. 
<p><b>3.60 16 June 2003</b> 
<p>We now SET CONCAT_NULL_YIELDS_NULL OFF for odbc_mssql driver to be compat with 
  mssql driver. 
<p>The property $emptyDate missing from connection class. Also changed 1903 to 
  constant (TIMESTAMP_FIRST_YEAR=100). Thx to Sebastiaan van Stijn. 
<p>ADOdb speedup optimization - we now return all arrays by reference. 
<p>Now DBDate() and DBTimeStamp() now accepts the string 'null' as a parameter. 
  Suggested by vincent. 
<p>Added GetArray() to connection class. 
<p>Added not_null check in informix metacolumns(). 
<p>Connection parameters for postgresql did not work correctly when port was defined. 
<p>DB2 is now a tested driver, making adodb 100% compatible. Extensive changes 
  to odbc driver for DB2, including implementing serverinfo() and SQLDate(), switching 
  to SQL_CUR_USE_ODBC as the cursor mode, and lastAffectedRows and SelectLimit() 
  fixes. 
<p>The odbc driver's FetchField() field names did not obey ADODB_ASSOC_CASE. Fixed. 
<p>Some bugs in adodb_backtrace() fixed. 
<p>Added "INT IDENTITY" type to adorecordset::MetaType() to support odbc_mssql 
  properly. 
<p>MetaColumns() for oci8, mssql, odbc revised to support scale. Also minor revisions 
  to odbc MetaColumns() for vfp and db2 compat. 
<p>Added unsigned support to mysql datadict class. Thx to iamsure. 
<p>Infinite loop in mssql MoveNext() fixed when ADODB_FETCH_ASSOC used. Thx to 
  Josh R, Night_Wulfe#hotmail.com. 
<p>ChangeTableSQL contributed by Florian Buzin. 
<p>The odbc_mssql driver now sets CONCAT_NULL_YIELDS_NULL OFF for compat with 
  mssql driver. 
<hr>
<p><strong>0.10 Sept 9 2000</strong> First release 
<h3><strong>Old changelog history moved to <a href=old-changelog.htm>old-changelog.htm</a>. 
  </strong></h3>
<p>&nbsp;</p>
<p>
</body>
</html>
